export module tester:runner;
import :output;
import :engine;
import std;

namespace tester
{

using namespace std::literals;
using namespace data;

export class runner
{
public:

    explicit runner(std::string_view tags = "") : m_tags{tags}
    {
        if(not m_tags.empty())
        {
            try
            {
                m_regex = std::regex{m_tags.begin(), m_tags.end()};
                m_use_regex = true;
            }
            catch(const std::regex_error&)
            {
                // Invalid regex, fall back to substring matching
                m_use_regex = false;
            }
        }
    }

    auto print_test_cases()
    {
        output::print_test_cases([this](const auto& tc){return this->included(tc);});
    }

    auto run_tests()
    {
        engine::run_test_cases([this](const auto& tc){return this->excluded(tc);});
    }

    auto print_test_results()
    {
        output::print_test_results();
    }

    auto print_test_failures()
    {
        output::print_test_failures();
    }

    auto print_test_statistics()
    {
        output::print_test_statistics();
    }

    bool included(const test_case& tc) const
    {
        return included(tc.test_name);
    }

    bool included(std::string_view test_name) const
    {
        if(m_tags.empty())
            return true;
        
        if(not (test_name.starts_with("scenario") or test_name.starts_with("test_case")))
            return true;

        if(m_use_regex)
        {
            return std::regex_search(test_name.begin(), test_name.end(), m_regex);
        }
        else
        {
            return test_name.contains(m_tags);
        }
    }

private:

    std::string_view m_tags;
    std::regex m_regex;
    bool m_use_regex = false;

    bool excluded(const test_case& tc) const
    {
        return not included(tc);
    }
};

}
