// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

export module tester:runner;
import :output;
import :engine;
import :data;
import std;

namespace tester
{
using data::test_case;
using data::test_result;

export class runner
{
public:

    runner(std::string_view tags = "")
        : m_tags{tags}, m_run_mode{}, m_run_tags{}
    {
        if(not m_tags.empty())
        {
            if(auto tag_list = parse_tag_query(m_tags); not tag_list.empty())
            {
                m_literal_tags = std::move(tag_list);
                m_use_literal_tags = true;
            }
            else
            {
            try
            {
                m_regex = std::regex{m_tags.begin(), m_tags.end()};
                m_use_regex = true;
            }
            catch(const std::regex_error&)
            {
                // Invalid regex, fall back to substring matching
                m_use_regex = false;
                }
            }
        }
    }

    void begin_run(std::string_view mode)
    {
        m_run_has_started = true;
        m_run_started_unix_ms = std::chrono::system_clock::now();
        m_run_started_monotonic = std::chrono::steady_clock::now();
        m_run_finished_monotonic = std::chrono::steady_clock::time_point{};
        m_run_mode = std::string{mode};
        m_run_tags = std::string{m_tags};
        m_pending_run_end_passed = std::nullopt;
        m_run_end_emitted = false;
        m_current_test_id.clear();

        // Set current test ID for output module
        output::set_current_test_id(m_current_test_id);

        if(output::jsonl_enabled())
            output::begin_run(m_run_mode, m_run_tags, m_run_started_unix_ms);
    }

    void end_run(bool passed)
    {
        if(m_run_has_started)
            m_run_finished_monotonic = std::chrono::steady_clock::now();

        if(!output::jsonl_enabled()) return;

        // In "run" mode, we defer emitting run_end until after the summary so the JSONL stream
        // ends in a predictable order. For other modes (e.g. "list"), emit immediately.
        if(m_run_mode == "run")
        {
            m_pending_run_end_passed = passed;
            // run_end will be emitted by print_test_statistics
            return;
        }

        const auto ended_at = std::chrono::system_clock::now();
        output::end_run(m_run_mode, m_run_tags, passed, m_run_started_unix_ms, ended_at);
        m_run_end_emitted = true;
    }

    void set_current_test_id(std::string_view id)
    {
        m_current_test_id.assign(id.begin(), id.end());
        output::set_current_test_id(m_current_test_id);
    }

    void clear_current_test_id()
    {
        m_current_test_id.clear();
        output::set_current_test_id("");
    }

    std::string_view get_current_test_id() const
    {
        return m_current_test_id;
    }

    auto print_test_cases()
    {
        begin_run("list");

        output::print_test_cases(std::function<bool(const test_case&)>{[this](const test_case& tc){ return this->included(tc); }});

        end_run(true);
    }

    auto run_tests()
    {
        begin_run("run");

        engine::init_statistics(m_run_started_monotonic, m_run_started_unix_ms, m_run_tags);

        engine::run_test_cases(
            [this](const auto& tc){return this->excluded(tc);},
            [this](std::string_view id){ this->set_current_test_id(id); },
            [this]{ this->clear_current_test_id(); },
            [this]{ return this->get_current_test_id(); });

        engine::finish_statistics(m_run_finished_monotonic);
        end_run(all_tests_passed());
    }

    auto print_test_results()
    {
        output::print_test_results();
    }

    auto print_test_failures()
    {
        output::print_test_failures();
    }

    auto print_test_statistics()
    {
        output::print_test_statistics(
            m_pending_run_end_passed,
            m_run_end_emitted,
            m_run_mode);
    }

    bool all_tests_passed() const
    {
        return data::statistics().total_tests == data::statistics().successful_tests 
            && data::statistics().total_assertions == data::statistics().successful_assertions;
    }

    bool included(const test_case& tc) const
    {
        return included(tc.test_name);
    }

    bool included(std::string_view test_name) const
    {
        if(m_tags.empty())
            return true;
        
        if(not (test_name.starts_with("scenario") or test_name.starts_with("test_case")))
            return true;

        if(m_use_literal_tags)
        {
            return match_literal_tags(test_name);
        }
        else if(m_use_regex)
        {
            return std::regex_search(test_name.begin(), test_name.end(), m_regex);
        }
        else
        {
            return test_name.contains(m_tags);
        }
    }

private:

    std::string_view m_tags;
    std::regex m_regex;
    bool m_use_regex = false;
    bool m_use_literal_tags = false;
    std::vector<std::string> m_literal_tags;

    // Run state
    std::chrono::system_clock::time_point m_run_started_unix_ms{};
    std::chrono::steady_clock::time_point m_run_started_monotonic{};
    std::chrono::steady_clock::time_point m_run_finished_monotonic{};
    bool m_run_has_started = false;
    std::string m_run_mode;
    std::string m_run_tags;
    std::string m_current_test_id;
    std::optional<bool> m_pending_run_end_passed;
    bool m_run_end_emitted = false;

    static std::vector<std::string> parse_tag_query(std::string_view query)
    {
        auto tags = std::vector<std::string>{};
        auto pos = std::size_t{0};

        while(pos < query.size())
        {
            if(query[pos] != '[')
                return {};

            auto end = query.find(']', pos + 1);
            if(end == std::string_view::npos)
                return {};

            tags.emplace_back(query.substr(pos + 1, end - pos - 1));
            pos = end + 1;
        }

        return tags;
    }

    bool match_literal_tags(std::string_view test_name) const
    {
        if(m_literal_tags.empty())
            return true;

        auto test_tags = extract_tags(test_name);
        if(test_tags.empty())
            return false;

        for(const auto& required : m_literal_tags)
        {
            auto found = std::find(test_tags.begin(), test_tags.end(), required) != test_tags.end();
            if(not found)
                return false;
        }

        return true;
    }

    static std::vector<std::string> extract_tags(std::string_view test_name)
    {
        auto tags = std::vector<std::string>{};
        auto pos = std::size_t{0};

        while((pos = test_name.find('[', pos)) != std::string_view::npos)
        {
            auto end = test_name.find(']', pos + 1);
            if(end == std::string_view::npos)
                break;

            tags.emplace_back(test_name.substr(pos + 1, end - pos - 1));
            pos = end + 1;
        }

        return tags;
    }

    bool excluded(const test_case& tc) const
    {
        return not included(tc);
    }
};

}
