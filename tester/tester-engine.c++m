export module tester:engine;
import :output;
import :data;
import std;

namespace tester::engine {

using namespace data;
using namespace std::literals;

auto& make_test_case(std::string_view description, int priority, std::vector<std::string> depends_on, std::string id, const std::source_location location1, const std::source_location location2) noexcept
{
    auto test_type = std::string_view{location2.function_name()};
    
    if(test_type.contains("behavior_driven_development::"))
        test_type.remove_prefix(test_type.find("behavior_driven_development::") + "behavior_driven_development::"s.length());
    else if (test_type.contains("basic::"))
        test_type.remove_prefix(test_type.find("basic::") + "basic::"s.length());
    else
        std::terminate();

    test_type.remove_suffix(test_type.length() - test_type.find_first_of("("));

    auto test_name = std::string{test_type} + " -> "s + std::string{description};
    auto test_case = data::test_case{{location1.function_name(),test_name,location1.file_name(),location1.line(),location1.column(),location2.function_name()},data::test{},priority,depends_on,id.empty() ? test_name : id};

    if(test_type.contains("scenario") or test_type.contains("test_case"))
    {
        test_cases.push_back(test_case);
        return test_cases.back().run;
    }
    else
    {
        auto itr = test_cases.begin();
        if(test_type.starts_with("and_"))
            test_type.remove_prefix(4); // remove "and_"
        while(itr->test_name.starts_with("then") or
              itr->test_name.starts_with("and_then") or
              itr->test_name.contains(test_type)) // given, and_given, when, and_when, section
           ++itr;
        return test_cases.insert(itr,test_case)->run;
    }
}

auto sort_test_cases()
{
    // Build a map of test IDs to test cases for dependency resolution
    auto id_to_test = std::map<std::string, test_case*>{};
    for(auto& tc : test_cases)
    {
        if(not tc.id.empty())
            id_to_test[tc.id] = &tc;
    }

    // Calculate dependency levels (tests with no dependencies = level 0, etc.)
    auto levels = std::map<test_case*, int>{};
    auto calculate_level = [&](test_case* tc, auto& self) -> int
    {
        if(levels.contains(tc))
            return levels[tc];
        
        int max_dep_level = -1;
        for(const auto& dep_id : tc->depends_on)
        {
            if(auto it = id_to_test.find(dep_id); it != id_to_test.end())
                max_dep_level = std::max(max_dep_level, self(it->second, self));
        }
        levels[tc] = max_dep_level + 1;
        return levels[tc];
    };

    for(auto& tc : test_cases)
        calculate_level(&tc, calculate_level);

    // Sort: first by dependency level, then by priority
    auto sorted = std::vector<test_case*>{};
    for(auto& tc : test_cases)
        sorted.push_back(&tc);

    auto compare = [&levels](const test_case* a, const test_case* b) -> bool
    {
        const auto level_a = levels[const_cast<test_case*>(a)];
        const auto level_b = levels[const_cast<test_case*>(b)];
        if(level_a != level_b)
            return level_a < level_b;  // Lower level (dependencies) first
        return a->priority < b->priority;  // Within same level, lower priority first
    };
    std::stable_sort(sorted.begin(), sorted.end(), compare);

    // Copy test cases before clearing the list (to avoid invalidating pointers)
    auto test_cases_copy = std::vector<test_case>{};
    test_cases_copy.reserve(sorted.size());
    for(auto* tc : sorted)
        test_cases_copy.push_back(*tc);

    // Rebuild test_cases list in sorted order
    test_cases.clear();
    for(auto& tc : test_cases_copy)
        test_cases.push_back(tc);
}

auto run_test_cases(auto filter)
{
    sort_test_cases();

    while(not test_cases.empty())
    {
        auto tc = test_cases.begin();

        if(filter(*tc))
        {
            test_cases.erase(tc);
            continue;
        }

        output::test_case(*tc);

        auto tr = test_result{*tc};
        try
        {
            ++statistics.total_tests;
            tc->run();
            ++statistics.successful_tests;
        }
        catch(const std::exception& ex)
        {
            tr.success = false;
            output::exception(*tc,ex);
        }
        test_cases.erase(tc);
        tr.output = output::stream.view();
        test_results.push_back(tr);
    }
}

}