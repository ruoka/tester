export module tester:assertions;
import :output;
import :data;
import std;

namespace tester::assertions
{
    using namespace std::literals;
    using data::test;
    using data::statistics;

    // Exception thrown by fatal assertions (require_*)
    export class assertion_failure : public std::exception
    {
    public:
        assertion_failure(std::string message) : m_message{std::move(message)} {}
        const char* what() const noexcept override { return m_message.c_str(); }
    private:
        std::string m_message;
    };

    // Non-fatal assertion helper (check_*)
    export template<template <typename> class M, typename A, typename E>
    auto check(M<std::common_type_t<A,E>> match, A actual, E expected, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        const auto ok = match(actual,expected);
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
        return ok;
    };

    // Fatal assertion helper (require_*)
    export template<template <typename> class M, typename A, typename E>
    void require(M<std::common_type_t<A,E>> match, A actual, E expected, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        const auto ok = match(actual,expected);
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
        if(not ok)
        {
            throw assertion_failure{"Assertion failed"};
        }
    };

    // Non-fatal assertions (check_*) - continue on failure
    export template<typename A, typename E>
    auto check_eq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_neq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::not_equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_lt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::less<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_lteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::less_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_gt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::greater<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_gteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::greater_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export auto check_true(bool actual, const std::source_location location = std::source_location::current())
    {
        return check(std::equal_to<bool>{},actual,true,location);
    };

    export auto check_false(bool actual, const std::source_location location = std::source_location::current())
    {
        return check(std::equal_to<bool>{},actual,false,location);
    };

    // Fatal assertions (require_*) - throw on failure
    export template<typename A, typename E>
    void require_eq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_neq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::not_equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_lt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::less<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_lteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::less_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_gt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::greater<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_gteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::greater_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export void require_true(bool actual, const std::source_location location = std::source_location::current())
    {
        require(std::equal_to<bool>{},actual,true,location);
    };

    export void require_false(bool actual, const std::source_location location = std::source_location::current())
    {
        require(std::equal_to<bool>{},actual,false,location);
    };

    // Non-fatal exception assertions (check_*)
    export auto check_nothrow(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        auto actual = "none"sv;
        const auto expected = "none"sv;
        try
        {
            ++statistics.total_assertions;
            t();
        }
        catch(const std::exception& e)
        {
            ok = not ok;
            actual = typeid(e).name();
        }
        catch(...)
        {
            ok = not ok;
            actual = "?"sv;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    export auto check_throws(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        auto actual = "?"sv;
        const auto expected = "any"sv;
        try
        {
            ++statistics.total_assertions;
            t();
            ok = not ok;
            actual = "none"sv;
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
        }
        catch(...)
        {
            actual = "?"sv;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    export template<typename E>
    auto check_throws_as(auto&& t, E exception, const std::source_location location = std::source_location::current())
    {
        static_cast<void>(exception);
        auto ok = true;
        auto actual = "?"sv;
        const auto expected = typeid(E).name();
        try
        {
            ++statistics.total_assertions;
            t();
            ok = not ok;
        }
        catch(const E&)
        {
            actual = typeid(E).name();
        }
        catch(const std::exception& e)
        {
            ok = not ok;
            actual = typeid(e).name();
        }
        catch(...)
        {
            ok = not ok;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    // Fatal exception assertions (require_*)
    export void require_nothrow(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto actual = "none"sv;
        const auto expected = "none"sv;
        try
        {
            ++statistics.total_assertions;
            t();
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected no exception"};
        }
        catch(...)
        {
            actual = "?"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected no exception"};
        }
    }

    export void require_throws(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto actual = "?"sv;
        const auto expected = "any"sv;
        try
        {
            ++statistics.total_assertions;
            t();
            actual = "none"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception"};
        }
        catch(const assertion_failure&)
        {
            throw;
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
        catch(...)
        {
            actual = "?"sv;
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
    }

    export template<typename E>
    void require_throws_as(auto&& t, E exception, const std::source_location location = std::source_location::current())
    {
        static_cast<void>(exception);
        auto actual = "?"sv;
        const auto expected = typeid(E).name();
        try
        {
            ++statistics.total_assertions;
            t();
            actual = "none"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception of type " + std::string{expected}};
        }
        catch(const assertion_failure&)
        {
            throw;
        }
        catch(const E&)
        {
            actual = typeid(E).name();
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception of type " + std::string{expected} + " but got " + std::string{actual}};
        }
        catch(...)
        {
            actual = "?"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception of type " + std::string{expected}};
        }
    }

    export auto succeed(auto message, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        ++statistics.successful_assertions;
        output::message(true,message,location);
    }

    export auto failed(auto message, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        output::message(false,message,location);
    }

    export auto warning(auto message, const std::source_location location = std::source_location::current())
    {
        output::message(true,message,location);
    }

}
