export module tester:assertions;
import :output;
import :data;
import std;

namespace tester::assertions
{
    using namespace std::literals;
    using data::test;
    using data::statistics;

    // Check if type is a floating-point type
    template<typename T>
    constexpr bool is_floating_point_v = std::is_floating_point_v<T>;

    template<typename A, typename E>
    constexpr bool both_are_floating_point_v = is_floating_point_v<A> and is_floating_point_v<E>;

    // Floating-point comparator with epsilon tolerance
    template<typename T>
    requires std::is_floating_point_v<T>
    struct floating_point_equal
    {
        static constexpr T default_epsilon = T{1e-9};
        
        explicit floating_point_equal(T epsilon = default_epsilon) : m_epsilon(epsilon) {}
        
        bool operator()(T a, T b) const
        {
            // Handle infinities and NaNs
            if(std::isinf(a) or std::isinf(b))
                return a == b;
            if(std::isnan(a) or std::isnan(b))
                return std::isnan(a) and std::isnan(b);
            
            // Use relative tolerance for large numbers, absolute for small
            const auto diff = std::abs(a - b);
            const auto max_val = std::max(std::abs(a), std::abs(b));
            
            // Relative tolerance: compare with scaled epsilon
            if(max_val > T{1.0})
                return diff <= max_val * m_epsilon;
            
            // Absolute tolerance: for small values, use epsilon directly
            return diff <= m_epsilon;
        }
        
    private:
        T m_epsilon;
    };

    export template<template <typename> class M, typename A, typename E>
    auto require(M<std::common_type_t<A,E>> match, A actual, E expected, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        const auto ok = match(actual,expected);
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
        return ok;
    };

    // Specialization for floating-point equality comparison
    export template<typename A, typename E>
    requires both_are_floating_point_v<A,E>
    auto require_eq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        using CommonType = std::common_type_t<A,E>;
        auto comparator = floating_point_equal<CommonType>{};
        return require(comparator, static_cast<CommonType>(actual), static_cast<CommonType>(expected), location);
    };

    // General equality comparison (for non-floating-point types)
    export template<typename A, typename E>
    requires (not both_are_floating_point_v<A,E>)
    auto require_eq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_neq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::not_equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_lt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::less<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_lteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::less_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_gt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::greater<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_gteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::greater_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export auto require_true(bool actual, const std::source_location location = std::source_location::current())
    {
        return require(std::equal_to<bool>{},actual,true,location);
    };

    export auto require_false(bool actual, const std::source_location location = std::source_location::current())
    {
        return require(std::equal_to<bool>{},actual,false,location);
    };

    export auto require_nothrow(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        auto actual = "none"sv;
        const auto expected = "none"sv;
        try
        {
            ++statistics.total_assertions;
            t();
            // ok = ok;
        }
        catch(const std::exception& e)
        {
            ok = not ok;
            actual = typeid(e).name();
        }
        catch(...)
        {
            ok = not ok;
            actual = "?"sv;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    export auto require_throws(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        auto actual = "?"sv;
        const auto expected = "any"sv;
        try
        {
            ++statistics.total_assertions;
            t(); // FIXME
            ok = not ok;
            actual = "none"sv;
        }
        catch(const std::exception& e)
        {
            // ok = ok;
            actual = typeid(e).name();
        }
        catch(...)
        {
            // ok = ok;
            actual = "?"sv;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    export template<typename E>
    auto require_throws_as(auto&& t, E exception, const std::source_location location = std::source_location::current())
    {
        static_cast<void>(exception);
        auto ok = true;
        auto actual = "?"sv;
        const auto expected = typeid(E).name();
        try
        {
            ++statistics.total_assertions;
            t(); // FIXME?
            ok = not ok;
        }
        catch(const E&)
        {
            // ok = ok;
            actual = typeid(E).name();
        }
        catch(const std::exception& e)
        {
            ok = not ok;
            actual = typeid(e).name();
        }
        catch(...)
        {
            ok = not ok;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    export auto succeed(auto message, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        ++statistics.successful_assertions;
        output::message(true,message,location);
    }

    export auto failed(auto message, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        output::message(false,message,location);
    }

    export auto warning(auto message, const std::source_location location = std::source_location::current())
    {
        output::message(true,message,location);
    }

}
