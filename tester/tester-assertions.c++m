// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

export module tester:assertions;
import :output;
import :data;
import std;

namespace tester::assertions
{
    using namespace std::literals;
    using data::test;
    using data::statistics;

    // Exception thrown by fatal assertions (require_*)
    export class assertion_failure : public std::exception
    {
    public:
        assertion_failure(std::string message) : m_message{std::move(message)} {}
        const char* what() const noexcept override { return m_message.c_str(); }
    private:
        std::string m_message;
    };

    // Check if type is a floating-point type
    template<typename T>
    constexpr bool is_floating_point_v = std::is_floating_point_v<T>;

    template<typename A, typename E>
    constexpr bool both_are_floating_point_v = is_floating_point_v<A> and is_floating_point_v<E>;

    // Floating-point comparator with epsilon tolerance
    template<typename T>
    requires std::is_floating_point_v<T>
    struct floating_point_equal
    {
        static constexpr T default_epsilon = T{1e-9};
        
        explicit floating_point_equal(T epsilon = default_epsilon) : m_epsilon(epsilon) {}
        
        bool operator()(T a, T b) const
        {
            // Handle infinities and NaNs
            if(std::isinf(a) or std::isinf(b))
                return a == b;
            if(std::isnan(a) or std::isnan(b))
                return std::isnan(a) and std::isnan(b);
            
            // Use relative tolerance for large numbers, absolute for small
            const auto diff = std::abs(a - b);
            const auto max_val = std::max(std::abs(a), std::abs(b));
            
            // Relative tolerance: compare with scaled epsilon
            if(max_val > T{1.0})
                return diff <= max_val * m_epsilon;
            
            // Absolute tolerance: for small values, use epsilon directly
            return diff <= m_epsilon;
        }
        
    private:
        T m_epsilon;
    };

    // Non-fatal assertion helper (check_*)
    export template<template <typename> class M, typename A, typename E>
    auto check(M<std::common_type_t<A,E>> match, A actual, E expected, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        const auto ok = match(actual,expected);
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
        return ok;
    };

    // Fatal assertion helper (require_*)
    export template<template <typename> class M, typename A, typename E>
    void require(M<std::common_type_t<A,E>> match, A actual, E expected, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        const auto ok = match(actual,expected);
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
        if(not ok)
        {
            throw assertion_failure{"Assertion failed"};
        }
    };

    // Equality and relational assertions (paired non-fatal/fatal helpers)
    export template<typename A, typename E>
    auto check_eq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        if constexpr (both_are_floating_point_v<A,E>)
        {
            using CommonType = std::common_type_t<A,E>;
            auto comparator = floating_point_equal<CommonType>{};
            return check(comparator, static_cast<CommonType>(actual), static_cast<CommonType>(expected), location);
        }
        else
        {
            return check(std::equal_to<std::common_type_t<A,E>>{},actual,expected,location);
        }
    };

    export template<typename A, typename E>
    void require_eq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        if constexpr (both_are_floating_point_v<A,E>)
        {
            using CommonType = std::common_type_t<A,E>;
            auto comparator = floating_point_equal<CommonType>{};
            require(comparator, static_cast<CommonType>(actual), static_cast<CommonType>(expected), location);
        }
        else
        {
            require(std::equal_to<std::common_type_t<A,E>>{},actual,expected,location);
        }
    };

    export template<typename A, typename E, typename T = std::common_type_t<A,E>>
    requires std::is_floating_point_v<T>
    auto check_near(A actual, E expected, T epsilon = floating_point_equal<T>::default_epsilon, const std::source_location location = std::source_location::current())
    {
        auto comparator = floating_point_equal<T>{epsilon};
        return check(comparator, static_cast<T>(actual), static_cast<T>(expected), location);
    };

    export template<typename A, typename E, typename T = std::common_type_t<A,E>>
    requires std::is_floating_point_v<T>
    void require_near(A actual, E expected, T epsilon = floating_point_equal<T>::default_epsilon, const std::source_location location = std::source_location::current())
    {
        auto comparator = floating_point_equal<T>{epsilon};
        require(comparator, static_cast<T>(actual), static_cast<T>(expected), location);
    };

    export template<typename A, typename E>
    auto check_neq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::not_equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_neq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::not_equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_lt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::less<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_lt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::less<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_lteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::less_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_lteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::less_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_gt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::greater<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_gt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::greater<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto check_gteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return check(std::greater_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    void require_gteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        require(std::greater_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export auto check_true(bool actual, const std::source_location location = std::source_location::current())
    {
        return check(std::equal_to<bool>{},actual,true,location);
    };

    export void require_true(bool actual, const std::source_location location = std::source_location::current())
    {
        require(std::equal_to<bool>{},actual,true,location);
    };

    export auto check_false(bool actual, const std::source_location location = std::source_location::current())
    {
        return check(std::equal_to<bool>{},actual,false,location);
    };

    export void require_false(bool actual, const std::source_location location = std::source_location::current())
    {
        require(std::equal_to<bool>{},actual,false,location);
    };

    // Non-fatal exception assertions (check_*)
    export auto check_nothrow(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        auto actual = "none"sv;
        const auto expected = "none"sv;
        try
        {
            ++statistics.total_assertions;
            t();
        }
        catch(const std::exception& e)
        {
            ok = not ok;
            actual = typeid(e).name();
        }
        catch(...)
        {
            ok = not ok;
            actual = "?"sv;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    export auto check_throws(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        auto actual = "?"sv;
        const auto expected = "any"sv;
        try
        {
            ++statistics.total_assertions;
            t();
            ok = not ok;
            actual = "none"sv;
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
        }
        catch(...)
        {
            actual = "?"sv;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    export template<typename E>
    auto check_throws_as(auto&& t, E exception, const std::source_location location = std::source_location::current())
    {
        static_cast<void>(exception);
        auto ok = true;
        auto actual = "?"sv;
        const auto expected = typeid(E).name();
        try
        {
            ++statistics.total_assertions;
            t();
            ok = not ok;
        }
        catch(const E&)
        {
            actual = typeid(E).name();
        }
        catch(const std::exception& e)
        {
            ok = not ok;
            actual = typeid(e).name();
        }
        catch(...)
        {
            ok = not ok;
        }
        statistics.successful_assertions += ok;
        output::assertion(ok,actual,expected,location);
    }

    // Fatal exception assertions (require_*)
    export void require_nothrow(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto actual = "none"sv;
        const auto expected = "none"sv;
        try
        {
            ++statistics.total_assertions;
            t();
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected no exception"};
        }
        catch(...)
        {
            actual = "?"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected no exception"};
        }
    }

    export void require_throws(auto&& t, const std::source_location location = std::source_location::current())
    {
        auto actual = "?"sv;
        const auto expected = "any"sv;
        try
        {
            ++statistics.total_assertions;
            t();
            actual = "none"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception"};
        }
        catch(const assertion_failure&)
        {
            throw;
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
        catch(...)
        {
            actual = "?"sv;
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
    }

    export template<typename E>
    void require_throws_as(auto&& t, E exception, const std::source_location location = std::source_location::current())
    {
        static_cast<void>(exception);
        auto actual = "?"sv;
        const auto expected = typeid(E).name();
        try
        {
            ++statistics.total_assertions;
            t();
            actual = "none"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception of type " + std::string{expected}};
        }
        catch(const assertion_failure&)
        {
            throw;
        }
        catch(const E&)
        {
            actual = typeid(E).name();
            ++statistics.successful_assertions;
            output::assertion(true,actual,expected,location);
        }
        catch(const std::exception& e)
        {
            actual = typeid(e).name();
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception of type " + std::string{expected} + " but got " + std::string{actual}};
        }
        catch(...)
        {
            actual = "?"sv;
            output::assertion(false,actual,expected,location);
            throw assertion_failure{"Assertion failed: expected exception of type " + std::string{expected}};
        }
    }

    export auto succeed(auto message, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        ++statistics.successful_assertions;
        output::message(true,message,location);
    }

    export auto failed(auto message, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        output::message(false,message,location);
    }

    export auto warning(auto message, const std::source_location location = std::source_location::current())
    {
        output::message(true,message,location);
    }

}
