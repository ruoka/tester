// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

module;
#include "details/output-mux.h++"

export module tester:jsonl_sink;

import std;

namespace tester::output::jsonl
{

namespace {

auto strip_ansi(std::string_view sv) -> std::string
{
    // Strip common ANSI escape sequences so JSONL output stays clean.
    // Best-effort filter for sequences like: ESC [ ... letter
    auto out = std::string{};
    out.reserve(sv.size());

    for(std::size_t i = 0; i < sv.size(); )
    {
        const unsigned char ch = static_cast<unsigned char>(sv[i]);
        if(ch == 0x1B && (i + 1) < sv.size() && sv[i + 1] == '[') // ESC [
        {
            i += 2;
            while(i < sv.size())
            {
                const unsigned char c = static_cast<unsigned char>(sv[i]);
                // CSI final byte is in the range 0x40..0x7E.
                if(c >= 0x40 && c <= 0x7E) { ++i; break; }
                ++i;
            }
            continue;
        }

        out.push_back(static_cast<char>(ch));
        ++i;
    }

    return out;
}

struct prepared_output
{
    std::string out{};
    bool truncated = false;
    std::size_t original_bytes = 0;
};

auto prepare_output(std::string_view raw, std::size_t max_bytes) -> prepared_output
{
    auto cleaned = strip_ansi(raw);
    const auto original_bytes = cleaned.size();

    auto truncated = false;
    if(max_bytes > 0 && cleaned.size() > max_bytes)
    {
        cleaned.resize(max_bytes);
        cleaned.append("...(truncated)");
        truncated = true;
    }

    return prepared_output{std::move(cleaned), truncated, original_bytes};
}

} // namespace

struct slow_test
{
    std::string id{};
    std::string_view name{};
    std::string_view file{};
    std::uint_least32_t line{};
    std::uint_least32_t column{};
    std::chrono::milliseconds duration{};
};

struct sink
{
    io::mux& m;

    explicit sink(io::mux& mux) : m(mux) {}

    void run_start(std::string_view mode, std::string_view tags, std::chrono::system_clock::time_point started_at)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("run_start", started_at) << [&](std::ostream& os){
            os << ",\"mode\":\"" << jsonl_util::escape(mode) << "\"";
            os << ",\"tags\":\"" << jsonl_util::escape(tags) << "\"";
        };
    }

    void run_end(std::string_view mode, std::string_view tags, bool passed, std::chrono::milliseconds duration, std::chrono::system_clock::time_point ended_at)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("run_end", ended_at) << [&](std::ostream& os){
            os << ",\"mode\":\"" << jsonl_util::escape(mode) << "\"";
            os << ",\"tags\":\"" << jsonl_util::escape(tags) << "\"";
            os << ",\"passed\":" << (passed ? "true" : "false");
            os << ",\"duration_ms\":" << duration.count();
        };
    }

    void case_event(std::string_view id,
                    std::string_view set,
                    std::string_view name,
                    std::string_view file,
                    std::uint_least32_t line,
                    std::uint_least32_t column)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("case") << [&](std::ostream& os){
            os << ",\"id\":\"" << jsonl_util::escape(id) << "\"";
            os << ",\"set\":\"" << jsonl_util::escape(set) << "\"";
            os << ",\"name\":\"" << jsonl_util::escape(name) << "\"";
            os << ",\"file\":\"" << jsonl_util::escape(file) << "\"";
            os << ",\"line\":" << line;
            os << ",\"column\":" << column;
        };
    }

    void test_event(std::string_view id,
                    std::string_view set,
                    std::string_view name,
                    std::string_view file,
                    std::uint_least32_t line,
                    std::uint_least32_t column,
                    bool success,
                    std::chrono::milliseconds duration,
                    std::size_t assertions_ok,
                    std::size_t assertions_total,
                    std::chrono::system_clock::time_point started_at,
                    std::chrono::system_clock::time_point finished_at,
                    bool include_output,
                    std::string_view raw_output,
                    std::size_t max_output_bytes)
    {
        auto prepared = prepared_output{};
        if(include_output)
            prepared = prepare_output(raw_output, max_output_bytes);

        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("test") << [&](std::ostream& os){
            os << ",\"id\":\"" << jsonl_util::escape(id) << "\"";
            os << ",\"set\":\"" << jsonl_util::escape(set) << "\"";
            os << ",\"name\":\"" << jsonl_util::escape(name) << "\"";
            os << ",\"file\":\"" << jsonl_util::escape(file) << "\"";
            os << ",\"line\":" << line;
            os << ",\"column\":" << column;
            os << ",\"success\":" << (success ? "true" : "false");
            os << ",\"duration_ms\":" << duration.count();
            os << ",\"assertions_ok\":" << assertions_ok;
            os << ",\"assertions_total\":" << assertions_total;
            os << ",\"started_unix_ms\":" << jsonl_util::unix_ms(started_at).count();
            os << ",\"finished_unix_ms\":" << jsonl_util::unix_ms(finished_at).count();
            if(include_output)
            {
                os << ",\"output\":\"" << jsonl_util::escape(prepared.out) << "\"";
                os << ",\"output_truncated\":" << (prepared.truncated ? "true" : "false");
                os << ",\"output_bytes\":" << prepared.original_bytes;
            }
        };
    }

    void assertion_event(bool ok,
                         std::string_view matcher,
                         std::string_view actual_json,
                         std::string_view expected_json,
                         std::string_view test_id,
                         std::string_view file,
                         std::uint_least32_t line,
                         std::uint_least32_t column)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl(ok ? "assertion_passed" : "assertion_failed") << [&](std::ostream& os){
            os << ",\"test_id\":\"" << jsonl_util::escape(test_id) << "\"";
            os << ",\"matcher\":\"" << jsonl_util::escape(matcher) << "\"";
            os << ",\"actual\":" << actual_json;
            os << ",\"expected\":" << expected_json;
            os << ",\"file\":\"" << jsonl_util::escape(file) << "\"";
            os << ",\"line\":" << line;
            os << ",\"column\":" << column;
        };
    }

    void summary(std::size_t tests_ok,
                 std::size_t tests_total,
                 std::size_t assertions_ok,
                 std::size_t assertions_total,
                 bool passed,
                 std::span<const slow_test> slowest)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("summary") << [&](std::ostream& os){
            os << ",\"tests_ok\":" << tests_ok;
            os << ",\"tests_total\":" << tests_total;
            os << ",\"assertions_ok\":" << assertions_ok;
            os << ",\"assertions_total\":" << assertions_total;
            os << ",\"passed\":" << (passed ? "true" : "false");
            if(!slowest.empty())
            {
                os << ",\"slowest\":[";
                for(std::size_t i = 0; i < slowest.size(); ++i)
                {
                    const auto& r = slowest[i];
                    if(i) os << ",";
                    os << "{\"id\":\"" << jsonl_util::escape(r.id) << "\"";
                    os << ",\"name\":\"" << jsonl_util::escape(r.name) << "\"";
                    os << ",\"file\":\"" << jsonl_util::escape(r.file) << "\"";
                    os << ",\"line\":" << r.line;
                    os << ",\"column\":" << r.column;
                    os << ",\"duration_ms\":" << r.duration.count();
                    os << "}";
                }
                os << "]";
            }
        };
    }
};

} // namespace tester::output::jsonl


