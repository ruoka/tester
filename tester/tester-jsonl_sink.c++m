// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

module;
#include "details/output-mux.h++"

export module tester:jsonl_sink;

import :data;
import std;

namespace tester::output::jsonl
{

namespace {

auto strip_ansi(std::string_view sv) -> std::string
{
    auto out = std::string{};
    out.reserve(sv.size());

    for(std::size_t i = 0; i < sv.size(); )
    {
        const unsigned char ch = static_cast<unsigned char>(sv[i]);
        if(ch == 0x1B && (i + 1) < sv.size() && sv[i + 1] == '[') // ESC [
        {
            i += 2;
            while(i < sv.size())
            {
                const unsigned char c = static_cast<unsigned char>(sv[i]);
                if(c >= 0x40 && c <= 0x7E) { ++i; break; }
                ++i;
            }
            continue;
        }

        out.push_back(static_cast<char>(ch));
        ++i;
    }

    return out;
}

struct prepared_output
{
    std::string out{};
    bool truncated = false;
    std::size_t original_bytes = 0;
};

auto prepare_output(std::string_view raw, std::size_t max_bytes) -> prepared_output
{
    auto cleaned = strip_ansi(raw);
    const auto original_bytes = cleaned.size();

    auto truncated = false;
    if(max_bytes > 0 && cleaned.size() > max_bytes)
    {
        cleaned.resize(max_bytes);
        cleaned.append("...(truncated)");
        truncated = true;
    }

    return prepared_output{std::move(cleaned), truncated, original_bytes};
}

} // namespace

export struct sink
{
    io::mux& m;

    explicit sink(io::mux& mux) : m(mux) {}

    void run_start(std::string_view mode, std::string_view tags, std::chrono::system_clock::time_point started_at)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("run_start", started_at) << [&](std::ostream& os){
            os << ",\"mode\":\"" << ::jsonl::escape(mode) << "\"";
            os << ",\"tags\":\"" << ::jsonl::escape(tags) << "\"";
        };
    }

    void run_end(std::string_view mode, std::string_view tags, bool passed, std::chrono::system_clock::time_point started, std::chrono::system_clock::time_point ended)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        const auto duration = (started != std::chrono::system_clock::time_point{})
            ? std::chrono::duration_cast<std::chrono::milliseconds>(ended - started)
            : std::chrono::milliseconds{0};
        m.json << m.jsonl("run_end", ended) << [&](std::ostream& os){
            os << ",\"mode\":\"" << ::jsonl::escape(mode) << "\"";
            os << ",\"tags\":\"" << ::jsonl::escape(tags) << "\"";
            os << ",\"passed\":" << (passed ? "true" : "false");
            os << ",\"duration_ms\":" << duration.count();
        };
    }

    void test_case(const data::test_case& tc)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("case") << [&](std::ostream& os){
            os << ",\"id\":\"" << ::jsonl::escape(tc.test_id) << "\"";
            os << ",\"set\":\"" << ::jsonl::escape(tc.test_set_name) << "\"";
            os << ",\"name\":\"" << ::jsonl::escape(tc.test_name) << "\"";
            os << ",\"file\":\"" << ::jsonl::escape(tc.file_name) << "\"";
            os << ",\"line\":" << tc.line;
            os << ",\"column\":" << tc.column;
        };
    }

    void test(const data::test_result& r, bool include_output, std::size_t max_output_bytes)
    {
        auto prepared = prepared_output{};
        if(include_output)
            prepared = prepare_output(r.output, max_output_bytes);

        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("test") << [&](std::ostream& os){
            os << ",\"id\":\"" << ::jsonl::escape(r.test_id) << "\"";
            os << ",\"set\":\"" << ::jsonl::escape(r.test_set_name) << "\"";
            os << ",\"name\":\"" << ::jsonl::escape(r.test_name) << "\"";
            os << ",\"file\":\"" << ::jsonl::escape(r.file_name) << "\"";
            os << ",\"line\":" << r.line;
            os << ",\"column\":" << r.column;
            os << ",\"success\":" << (r.success ? "true" : "false");
            os << ",\"duration_ms\":" << std::chrono::duration_cast<std::chrono::milliseconds>(r.duration).count();
            os << ",\"assertions_ok\":" << r.assertions_ok;
            os << ",\"assertions_total\":" << r.assertions_total;
            os << ",\"started_unix_ms\":" << ::jsonl::unix_ms(r.started_at).count();
            os << ",\"finished_unix_ms\":" << ::jsonl::unix_ms(r.finished_at).count();
            if(include_output)
            {
                os << ",\"output\":\"" << ::jsonl::escape(prepared.out) << "\"";
                os << ",\"output_truncated\":" << (prepared.truncated ? "true" : "false");
                os << ",\"output_bytes\":" << prepared.original_bytes;
            }
        };
    }

    void assertion_event(const data::test_assertion& a)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl(a.ok ? "assertion_passed" : "assertion_failed") << [&](std::ostream& os){
            os << ",\"test_id\":\"" << ::jsonl::escape(a.test_id) << "\"";
            os << ",\"matcher\":\"" << ::jsonl::escape(a.matcher) << "\"";
            os << ",\"actual\":" << a.actual;
            os << ",\"expected\":" << a.expected;
            os << ",\"file\":\"" << ::jsonl::escape(a.file) << "\"";
            os << ",\"line\":" << a.line;
            os << ",\"column\":" << a.column;
        };
    }

    void message(bool ok, std::string_view msg, const std::source_location& location1, const std::source_location& location2)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("message") << [&](std::ostream& os){
            os << ",\"ok\":" << (ok ? "true" : "false");
            os << ",\"message\":\"" << ::jsonl::escape(msg) << "\"";
            os << ",\"file\":\"" << ::jsonl::escape(location1.file_name()) << "\"";
            os << ",\"line\":" << location1.line();
            os << ",\"column\":" << location1.column();
            os << ",\"caller_file\":\"" << ::jsonl::escape(location2.file_name()) << "\"";
            os << ",\"caller_line\":" << location2.line();
        };
    }

    void on_exception(const data::test_case& tc, const std::exception& ex)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("exception") << [&](std::ostream& os){
            os << ",\"test_id\":\"" << ::jsonl::escape(tc.test_id) << "\"";
            os << ",\"message\":\"" << ::jsonl::escape(ex.what()) << "\"";
            os << ",\"file\":\"" << ::jsonl::escape(tc.file_name) << "\"";
            os << ",\"line\":" << tc.line;
            os << ",\"column\":" << tc.column;
        };
    }

    void summary(const data::test_statistics& s,
                 bool passed,
                 std::span<const data::test_result* const> slowest)
    {
        auto lock = std::lock_guard<std::mutex>{m.mutex};
        m.json << m.jsonl("summary") << [&](std::ostream& os){
            os << ",\"tests_ok\":" << s.successful_tests;
            os << ",\"tests_total\":" << s.total_tests;
            os << ",\"assertions_ok\":" << s.successful_assertions;
            os << ",\"assertions_total\":" << s.total_assertions;
            os << ",\"passed\":" << (passed ? "true" : "false");
            if(!slowest.empty())
            {
                os << ",\"slowest\":[";
                for(std::size_t i = 0; i < slowest.size(); ++i)
                {
                    const auto& r = *slowest[i];
                    if(i) os << ",";
                    os << "{\"id\":\"" << ::jsonl::escape(r.test_id) << "\"";
                    os << ",\"name\":\"" << ::jsonl::escape(r.test_name) << "\"";
                    os << ",\"file\":\"" << ::jsonl::escape(r.file_name) << "\"";
                    os << ",\"line\":" << r.line;
                    os << ",\"column\":" << r.column;
                    os << ",\"duration_ms\":" << std::chrono::duration_cast<std::chrono::milliseconds>(r.duration).count();
                    os << "}";
                }
                os << "]";
            }
        };
    }
};

} // namespace tester::output::jsonl

