export module tester;
import std;

namespace tester
{
using namespace std::literals;

namespace color
{
    constinit auto reset   = "\033[0m";

    namespace text
    {
        constinit auto black   = "\033[30m"; // black
        constinit auto red     = "\033[31m"; // red
        constinit auto green   = "\033[32m"; // green
        constinit auto yellow  = "\033[33m"; // yellow
        constinit auto blue    = "\033[34m"; // blue
        constinit auto magenta = "\033[35m"; // magenta
        constinit auto cyan    = "\033[36m"; // cyan
        constinit auto white   = "\033[37m"; // white
    }

    namespace background
    {
        constinit auto black   = "\033[40m"; // black
        constinit auto red     = "\033[41m"; // red
        constinit auto green   = "\033[42m"; // green
        constinit auto yellow  = "\033[43m"; // yellow
        constinit auto blue    = "\033[44m"; // blue
        constinit auto magenta = "\033[45m"; // magenta
        constinit auto cyan    = "\033[46m"; // cyan
        constinit auto white   = "\033[47m"; // white
    }
}

using test = std::function<void(void)>;

struct test_case
{
    const std::string test_name;
    const std::string_view file_name;
    const std::uint_least32_t line;
    const std::uint_least32_t column;
    const std::string_view function_name;
    test run;
};

auto test_cases = std::list<test_case>{};

struct test_result : public test_case
{
    bool success;
    std::string output;
};

auto test_results = std::list<test_result>{};

struct test_statistics
{
    std::size_t successful_tests;
    std::size_t total_tests;
    std::size_t successful_assertions;
    std::size_t total_assertions;
};

auto statistics = test_statistics{0,0,0,0};

auto stream = std::ostringstream{};

export class test_runner
{
    private:

    std::string_view m_tests;

    auto include(const test_case& tc) const
    {
        return m_tests.empty() or
               not (tc.test_name.starts_with("scenario") or tc.test_name.starts_with("test_case")) or
               tc.test_name.contains(m_tests);
    }

    auto filter(const test_case& tc) const
    {
        return not include(tc);
    }

    public:

    test_runner(std::string_view tests = "") : m_tests{tests}
    {}

    auto print_test_cases()
    {
        std::clog << "Test cases:\n";
        for(auto tc : test_cases)
            if(include(tc))
                std::clog << color::text::yellow
                          << tc.test_name
                          << " (" << tc.file_name << " " << tc.line << ':' << tc.column << ")"
                          << color::reset << std::endl;
    }

    auto run_tests()
    {
        while(not test_cases.empty())
        {
            auto tc = test_cases.begin();
            auto tr = test_result{*tc,true,""s};
            stream = std::ostringstream{};

            if(filter(*tc))
            {
                test_cases.erase(tc);
                continue;
            }

            try
            {
                stream << color::text::blue
                       << tc->test_name << " "
                       << "(" << tc->file_name << " " <<  tc->line << ":" <<  tc->column << ")"
                       << color::reset << std::endl;

                ++statistics.total_tests;
                tc->run();
                ++statistics.successful_tests;
            }
            catch(const std::exception& e)
            {
                auto ss = std::ostringstream{};
                ss << color::background::red
                   << e.what()
                   << " " << tc->test_name << " "
                   << "(" << tc->file_name << " " <<  tc->line << ":" <<  tc->column << ")"
                   << color::reset << std::endl;

                   tr.success = false;
                   stream << ss.view();
            }
            tr.output = stream.view();
            test_cases.erase(tc);
            test_results.push_back(tr);
        }
    }

    auto print_test_results()
    {
        std::clog << color::text::yellow
                  << "Test results:" << '\n';
        for(auto result : test_results)
            std::clog << result.output;
    }

    auto print_test_failures()
    {
        std::clog << color::text::red
                  << "Test failures:" << '\n';
        for(auto result : test_results)
        {
            if(not result.success)
                std::clog << result.output;
        }
    }

    auto print_test_statistics()
    {
        std::clog << color::text::yellow
                  << "Test statistics:" << '\n'
                  << "total tests: "<< statistics.total_tests << '\n'
                  << "successful tests: "<< statistics.successful_tests << '\n'
                  << "total assertions: "<< statistics.total_assertions << '\n'
                  << "successful assertions: "<< statistics.successful_assertions
                  << color::reset << std::endl;
    }

};

inline auto& make_test_case(std::string_view description, const std::source_location location1, const std::source_location location2 = std::source_location::current()) noexcept
{
    auto test_type = std::string_view{location2.function_name()};
    
    if(test_type.contains("behavior_driven_development::"))
        test_type.remove_prefix(test_type.find("behavior_driven_development::") + "behavior_driven_development::"s.length());
    else
        test_type.remove_prefix(test_type.find("basic::") + "basic::"s.length());        

    test_type.remove_suffix(test_type.length() - test_type.find_first_of("("));

    auto test_name = std::string{test_type} + " -> "s + std::string{description};
    auto test_case = tester::test_case{test_name,location1.file_name(),location1.line(),location1.column(),location2.function_name(),test{}};

    if(test_type.contains("scenario") or test_type.contains("test_case"))
    {
        test_cases.push_back(test_case);
        return test_cases.back().run;
    }
    else
    {
        auto itr = test_cases.begin();
        while(itr->test_name.starts_with("then") or
             itr->test_name.starts_with("and_then") or
            itr->test_name.starts_with(test_type)) // give, and_give, when, and_when, then, and_then, section
           ++itr;
        if(test_type.starts_with("and_"))
        {
            test_type.remove_prefix(4); // remove "and_"
            while(itr->test_name.starts_with(test_type)) // mode and_give, and_when to the end
               ++itr;
        }
        return test_cases.insert(itr,test_case)->run;
    }
}

namespace basic
{
    export auto& test_case(std::string_view test_name, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(test_name, location);
    }

    export auto& section(std::string_view test_name, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(test_name, location);
    }
}

namespace behavior_driven_development
{
    export auto& scenario(std::string_view text, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(text, location);
    }

    export auto& given(std::string_view text, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(text, location);
    }

    export auto& and_given(std::string_view text, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(text, location);
    }

    export auto& when(std::string_view text, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(text, location);
    }

    export auto& and_when(std::string_view text, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(text, location);
    }

    export auto& then(std::string_view text, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(text, location);
    }

    export auto& and_then(std::string_view text, const std::source_location location = std::source_location::current()) noexcept
    {
        return make_test_case(text, location);
    }
}

auto function_name(const std::source_location sl = std::source_location::current())
{
    auto function_name = std::string_view{sl.function_name()};
    function_name.remove_prefix(function_name.find("assertions::") + "assertions::"s.length());
    auto test_name = function_name.substr(0,function_name.find_first_of("("));
    auto parameters = function_name.contains("[") ? function_name.substr(function_name.find_first_of("[")) : ""sv;
    return std::string{test_name} + " -> "s + std::string{parameters};
}

template <typename V>
auto print(const V& value)
{
    if constexpr (std::is_pointer_v<V>)
        stream << (value != nullptr ? value : "nullptr");
    else if constexpr (std::is_enum_v<V>)
        stream << std::to_underlying(value);
    else if constexpr (std::chrono::is_clock_v<V>)
        stream << std::format("{0:%F}T{0:%T}", value);
    else
        stream << std::boolalpha << value;
}

template<typename A,typename E>
auto print(const bool ok, const A& actual, const E& expected, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
        if(ok)
            stream << color::text::green;
        else
            stream << color::text::red;

        stream << function_name(location2);
        
        stream << " actual: ";
        print(actual);

        stream << " expected: ";
        print(expected);

        stream << " ";

        stream << "(" << location1.file_name() << " " << location1.line() << ":" << location1.column() << ")"
                  << color::reset << std::endl;
}

namespace assertions
{
    export template<template <typename> class M, typename A, typename E>
    auto require(M<std::common_type_t<A,E>> match, A actual, E expected, const std::source_location location = std::source_location::current())
    {
        ++statistics.total_assertions;
        const auto ok = match(actual,expected);
        statistics.successful_assertions += ok;
        print(ok,actual,expected,location);
        return ok;
    };

    export template<typename A, typename E>
    auto require_eq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_neq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::not_equal_to<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_lt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::less<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_lteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::less_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_gt(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::greater<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export template<typename A, typename E>
    auto require_gteq(A actual, E expected, const std::source_location location = std::source_location::current())
    {
        return require(std::greater_equal<std::common_type_t<A,E>>{},actual,expected,location);
    };

    export auto require_true(bool actual, const std::source_location location = std::source_location::current())
    {
        return require(std::equal_to<bool>{},actual,true,location);
    };

    export auto require_false(bool actual, const std::source_location location = std::source_location::current())
    {
        return require(std::equal_to<bool>{},actual,false,location);
    };

    export auto require_nothrow(test t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        try
        {
            ++statistics.total_assertions;
            t();
        }
        catch(...)
        {
            ok = not ok;
        }
        statistics.successful_assertions += ok;
        print(ok,ok,true,location);
    }

    export auto require_throw(test t, const std::source_location location = std::source_location::current())
    {
        auto ok = true;
        try
        {
            ++statistics.total_assertions;
            t();
            ok = not ok;
        }
        catch(...)
        {}
        statistics.successful_assertions += ok;
        print(ok,ok,true,location);
    }
}

export namespace bdd = behavior_driven_development;

}
