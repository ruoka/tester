module;
#if defined(__GNUG__) && __has_include(<cxxabi.h>)
#   include <cxxabi.h>
#   define TESTER_HAVE_CXXABI 1
#else
#   define TESTER_HAVE_CXXABI 0
#endif

export module tester:output;
import :data;
import std;

namespace tester::output
{

namespace color
{
    constinit auto reset   = "\033[0m";

    namespace text
    {
        constinit auto black   = "\033[30m"; // black
        constinit auto red     = "\033[31m"; // red
        constinit auto green   = "\033[32m"; // green
        constinit auto yellow  = "\033[33m"; // yellow
        constinit auto blue    = "\033[34m"; // blue
        constinit auto magenta = "\033[35m"; // magenta
        constinit auto cyan    = "\033[36m"; // cyan
        constinit auto white   = "\033[37m"; // white
    }

    namespace background
    {
        constinit auto black   = "\033[40m"; // black
        constinit auto red     = "\033[41m"; // red
        constinit auto green   = "\033[42m"; // green
        constinit auto yellow  = "\033[43m"; // yellow
        constinit auto blue    = "\033[44m"; // blue
        constinit auto magenta = "\033[45m"; // magenta
        constinit auto cyan    = "\033[46m"; // cyan
        constinit auto white   = "\033[47m"; // white
    }
}

using namespace data;

void print_test_cases(auto included)
{
    std::clog << "Test cases:\n";
    for(auto tc : test_cases)
        if(included(tc))
            std::clog << color::text::yellow
                      << tc.test_name
                      << " (" << tc.file_name << " " << tc.line << ':' << tc.column << ")"
                      << color::reset << std::endl;
}

void print_test_results()
{
    std::clog << color::text::yellow
              << "Test results:"
              << color::reset << '\n';
    for(auto result : test_results)
        std::clog << result.output;
}

void print_test_failures()
{
    std::clog << color::text::red
              << "Test failures:"
              << color::reset << '\n';

    for(auto result : test_results)
        if(not result.success)
            std::clog << result.output;
}

void print_test_statistics()
{
    std::clog << color::text::yellow
              << "Test statistics:" << '\n'
              << "total tests: "<< statistics.total_tests << '\n'
              << "successful tests: "<< statistics.successful_tests << '\n'
              << "total assertions: "<< statistics.total_assertions << '\n'
              << "successful assertions: "<< statistics.successful_assertions
              << color::reset << std::endl;
}

auto verbose = false;

auto stream = std::ostringstream{};

void reset()
{
    stream = std::ostringstream{};
}

void test_case(const auto& tc)
{
    reset();

    if(tc.test_name.starts_with("scenario") or tc.test_name.starts_with("test_case"))
        stream << color::background::blue
            << tc.test_set_name
            << color::reset << '\n';

    stream << color::text::blue
           << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

void exception(const auto& tc, const auto& ex)
{
    stream << color::background::red
           << ex.what()
           << " " << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

auto demangle(std::string_view name)
{
#if TESTER_HAVE_CXXABI
    int status = 0;
    auto buffer = std::string{name};
    auto demangled = abi::__cxa_demangle(buffer.c_str(), nullptr, nullptr, &status);
    if(demangled != nullptr)
    {
        std::string result{demangled};
        std::free(demangled);
        return result;
    }
#endif
    return std::string{name};
}

auto function_name(const std::source_location sl = std::source_location::current())
{
    using namespace std::literals;
    auto name = std::string_view{sl.function_name()};

    if(auto assertions_pos = name.find("assertions::"); assertions_pos != std::string_view::npos)
        name.remove_prefix(assertions_pos + "assertions::"s.length());

    auto base = name.substr(0, name.find_first_of("("));
    auto display = std::string{base};

    if(auto bracket = name.find('['); bracket != std::string_view::npos)
    {
        auto end = name.find(']', bracket);
        auto parameters = end != std::string_view::npos
                          ? name.substr(bracket + 1, end - bracket - 1)
                          : name.substr(bracket + 1);

        auto trim = [](std::string_view sv)
        {
            auto start = sv.find_first_not_of(" \t");
            if(start == std::string_view::npos) return std::string_view{};
            auto finish = sv.find_last_not_of(" \t");
            return sv.substr(start, finish - start + 1);
        };

        auto clean = [](std::string text)
        {
            auto replace_all = [](std::string& target, std::string_view from, std::string_view to)
            {
                for(auto pos = target.find(from); pos != std::string::npos; pos = target.find(from, pos + to.size()))
                    target.replace(pos, from.size(), to);
            };

            replace_all(text, "std::__1::", "std::");
            replace_all(text, "std::basic_string<char>", "std::string");
            replace_all(text, "std::basic_string<wchar_t>", "std::wstring");
            replace_all(text, " >", ">");

            return text;
        };

        display.push_back(' ');
        display.push_back('[');

        auto remaining = parameters;
        auto first = true;
        while(true)
        {
            auto pos = remaining.find(',');
            auto token = trim(remaining.substr(0, pos));
            if(not token.empty())
            {
                if(not first) display.append(", ");
                auto eq = token.find('=');
                if(eq != std::string_view::npos)
                {
                    auto key = trim(token.substr(0, eq));
                    auto value = trim(token.substr(eq + 1));
                    display.append(std::string{key});
                    display.append("=");
                    display.append(demangle(clean(std::string{value})));
                }
                else
                {
                    display.append(demangle(clean(std::string{token})));
                }
                first = false;
            }
            if(pos == std::string_view::npos) break;
            remaining.remove_prefix(pos + 1);
        }

        display.push_back(']');
    }

    return display;
}

template<class T>
concept chrono_clock = requires {
    typename T::time_point;
    T::now();
};

template <typename V>
void value(const V& val)
{
    if constexpr (std::is_same_v<std::remove_cvref_t<V>, std::string>)
        stream << demangle(val);
    else if constexpr (std::is_same_v<std::remove_cvref_t<V>, std::string_view>)
        stream << demangle(std::string{val});
    else if constexpr (std::is_same_v<std::remove_cvref_t<V>, const char*>)
        stream << demangle(val != nullptr ? std::string{val} : std::string{"nullptr"});
    else if constexpr (std::is_same_v<std::remove_cvref_t<V>, char*>)
        stream << demangle(val != nullptr ? std::string{val} : std::string{"nullptr"});
    else if constexpr (std::is_pointer_v<V>)
        stream << (val != nullptr ? val : "nullptr");
    else if constexpr (std::is_enum_v<V>)
        stream << std::to_underlying(val);
    else if constexpr (chrono_clock<V>)
        stream << std::format("{0:%F}T{0:%T}", val);
    else
        stream << std::boolalpha << val;
}

template<typename A,typename E>
void assertion(const bool ok, const A& actual, const E& expected, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(ok)
        stream << color::text::green;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';

    stream << "  actual:   ";
    value(actual);
    stream << '\n';

    stream << "  expected: ";
    value(expected);
    stream << '\n';

    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

void message(const bool ok, auto message, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(ok)
        stream << color::text::yellow;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';
    stream << "  message:  " << message << '\n';
    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

}

#undef TESTER_HAVE_CXXABI