// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

module;
#if defined(__GNUG__) && __has_include(<cxxabi.h>)
#   include <cxxabi.h>
#   define TESTER_HAVE_CXXABI 1
#else
#   define TESTER_HAVE_CXXABI 0
#endif

export module tester:output;
import :data;
import std;

namespace tester::output
{

namespace color
{
    constinit auto reset   = "\033[0m";

    namespace text
    {
        constinit auto black   = "\033[30m"; // black
        constinit auto red     = "\033[31m"; // red
        constinit auto green   = "\033[32m"; // green
        constinit auto yellow  = "\033[33m"; // yellow
        constinit auto blue    = "\033[34m"; // blue
        constinit auto magenta = "\033[35m"; // magenta
        constinit auto cyan    = "\033[36m"; // cyan
        constinit auto white   = "\033[37m"; // white
    }

    namespace background
    {
        constinit auto black   = "\033[40m"; // black
        constinit auto red     = "\033[41m"; // red
        constinit auto green   = "\033[42m"; // green
        constinit auto yellow  = "\033[43m"; // yellow
        constinit auto blue    = "\033[44m"; // blue
        constinit auto magenta = "\033[45m"; // magenta
        constinit auto cyan    = "\033[46m"; // cyan
        constinit auto white   = "\033[47m"; // white
    }
}

using namespace data;

namespace {

enum class output_format { human, jsonl };

auto getenv_sv(const char* name) -> std::string_view
{
    if(const char* v = std::getenv(name))
        return std::string_view{v};
    return {};
}

auto parse_usize(std::string_view sv) -> std::optional<std::size_t>
{
    if(sv.empty()) return std::nullopt;
    std::size_t value = 0;
    for(const char ch : sv)
    {
        if(ch < '0' || ch > '9') return std::nullopt;
        value = value * 10u + static_cast<std::size_t>(ch - '0');
    }
    return value;
}

auto current_format() -> output_format
{
    static const auto fmt = []{
        auto v = getenv_sv("TESTER_OUTPUT");
        if(v == "jsonl" || v == "JSONL") return output_format::jsonl;
        return output_format::human;
    }();
    return fmt;
}

auto want_result_line() -> bool
{
    return current_format() == output_format::jsonl || getenv_sv("TESTER_RESULT") == "1";
}

auto slowest_count() -> std::size_t
{
    if(const auto n = parse_usize(getenv_sv("TESTER_SLOWEST")))
        return *n;
    return 0;
}

auto json_escape(std::string_view sv) -> std::string
{
    auto out = std::string{};
    out.reserve(sv.size() + 16);
    for(const unsigned char ch : sv)
    {
        switch(ch)
        {
            case '\\': out += "\\\\"; break;
            case '"':  out += "\\\""; break;
            case '\b': out += "\\b"; break;
            case '\f': out += "\\f"; break;
            case '\n': out += "\\n"; break;
            case '\r': out += "\\r"; break;
            case '\t': out += "\\t"; break;
            default:
                if(ch < 0x20)
                    out += std::format("\\u{:04x}", static_cast<unsigned int>(ch));
                else
                    out.push_back(static_cast<char>(ch));
        }
    }
    return out;
}

auto json_bool(bool b) -> std::string_view { return b ? "true" : "false"; }

auto strip_ansi(std::string_view sv) -> std::string
{
    // Strip common ANSI escape sequences so JSONL output stays clean.
    // This is a best-effort filter for sequences like: ESC [ ... letter
    auto out = std::string{};
    out.reserve(sv.size());

    for(std::size_t i = 0; i < sv.size(); )
    {
        const unsigned char ch = static_cast<unsigned char>(sv[i]);
        if(ch == 0x1B && (i + 1) < sv.size() && sv[i + 1] == '[') // ESC [
        {
            i += 2;
            while(i < sv.size())
            {
                const unsigned char c = static_cast<unsigned char>(sv[i]);
                // CSI final byte is in the range 0x40..0x7E.
                if(c >= 0x40 && c <= 0x7E) { ++i; break; }
                ++i;
            }
            continue;
        }

        out.push_back(static_cast<char>(ch));
        ++i;
    }

    return out;
}

} // namespace

void print_test_cases(auto included)
{
    if(current_format() == output_format::jsonl)
    {
        for(const auto& tc : test_cases)
        {
            if(!included(tc)) continue;
            std::clog
                << "{\"type\":\"case\""
                << ",\"set\":\"" << json_escape(tc.test_set_name) << "\""
                << ",\"name\":\"" << json_escape(tc.test_name) << "\""
                << ",\"file\":\"" << json_escape(tc.file_name) << "\""
                << ",\"line\":" << tc.line
                << ",\"column\":" << tc.column
                << "}\n";
        }
        return;
    }

    std::clog << "Test cases:\n";
    for(auto tc : test_cases)
        if(included(tc))
            std::clog << color::text::yellow
                      << tc.test_name
                      << " (" << tc.file_name << " " << tc.line << ':' << tc.column << ")"
                      << color::reset << std::endl;
}

void print_test_results()
{
    if(current_format() == output_format::jsonl)
    {
        const auto include_all_output = (getenv_sv("TESTER_JSONL_INCLUDE_OUTPUT") == "1");
        for(const auto& result : test_results)
        {
            const auto include_output = include_all_output || (not result.success);
            std::clog
                << "{\"type\":\"test\""
                << ",\"set\":\"" << json_escape(result.test_set_name) << "\""
                << ",\"name\":\"" << json_escape(result.test_name) << "\""
                << ",\"file\":\"" << json_escape(result.file_name) << "\""
                << ",\"line\":" << result.line
                << ",\"column\":" << result.column
                << ",\"success\":" << json_bool(result.success)
                << ",\"duration_ms\":" << result.duration_ms;
            if(include_output)
                std::clog << ",\"output\":\"" << json_escape(strip_ansi(result.output)) << "\"";
            std::clog << "}\n";
        }
        return;
    }

    std::clog << color::text::yellow
              << "Test results:"
              << color::reset << '\n';
    for(auto result : test_results)
        std::clog << result.output;
}

void print_test_failures()
{
    if(current_format() == output_format::jsonl)
        return;

    auto any_failures = false;
    for(const auto& result : test_results)
        if(not result.success) { any_failures = true; break; }

    if(!any_failures)
    {
        std::clog << color::text::green
                  << "No test failures."
                  << color::reset << '\n';
        return;
    }

    std::clog << color::text::red
              << "Test failures:"
              << color::reset << '\n';

    for(const auto& result : test_results)
        if(not result.success)
            std::clog << result.output;
}

void print_test_statistics()
{
    const auto failed_tests = statistics.total_tests - statistics.successful_tests;
    const auto failed_assertions = statistics.total_assertions - statistics.successful_assertions;

    auto pct = [](std::size_t ok, std::size_t total) -> double {
        if(total == 0) return 100.0;
        return 100.0 * static_cast<double>(ok) / static_cast<double>(total);
    };

    const auto passed = (failed_tests == 0 && failed_assertions == 0);

    const auto slow_n = slowest_count();
    auto slowest = std::vector<const test_result*>{};
    if(slow_n > 0)
    {
        slowest.reserve(test_results.size());
        for(const auto& r : test_results) slowest.push_back(&r);
        std::ranges::sort(slowest, [](const test_result* a, const test_result* b) {
            return a->duration_ms > b->duration_ms;
        });
        if(slowest.size() > slow_n) slowest.resize(slow_n);
    }

    if(current_format() == output_format::jsonl)
    {
        std::clog
            << "{\"type\":\"summary\""
            << ",\"tests_ok\":" << statistics.successful_tests
            << ",\"tests_total\":" << statistics.total_tests
            << ",\"assertions_ok\":" << statistics.successful_assertions
            << ",\"assertions_total\":" << statistics.total_assertions
            << ",\"passed\":" << json_bool(passed);

        if(!slowest.empty())
        {
            std::clog << ",\"slowest\":[";
            for(std::size_t i = 0; i < slowest.size(); ++i)
            {
                const auto& r = *slowest[i];
                if(i) std::clog << ",";
                std::clog
                    << "{\"name\":\"" << json_escape(r.test_name) << "\""
                    << ",\"duration_ms\":" << r.duration_ms
                    << "}";
            }
            std::clog << "]";
        }
        std::clog << "}\n";

        if(want_result_line())
        {
            std::clog
                << "RESULT:"
                << " tests_ok=" << statistics.successful_tests
                << " tests_total=" << statistics.total_tests
                << " assertions_ok=" << statistics.successful_assertions
                << " assertions_total=" << statistics.total_assertions
                << " passed=" << (passed ? "true" : "false")
                << '\n';
        }
        return;
    }

    std::clog << color::text::yellow
              << "Test statistics:" << '\n'
              << "tests:      " << statistics.successful_tests << "/" << statistics.total_tests
              << " passed"
              << " (" << std::fixed << std::setprecision(1) << pct(statistics.successful_tests, statistics.total_tests) << "%)"
              << " | failed: " << failed_tests << '\n'
              << "assertions: " << statistics.successful_assertions << "/" << statistics.total_assertions
              << " passed"
              << " (" << std::fixed << std::setprecision(1) << pct(statistics.successful_assertions, statistics.total_assertions) << "%)"
              << " | failed: " << failed_assertions
              << color::reset << std::endl;

    if(slow_n > 0)
    {
        std::clog << color::text::yellow << "Slowest tests:" << color::reset << '\n';
        for(const auto* r : slowest)
        {
            std::clog
                << "  " << r->duration_ms << "ms  "
                << r->test_name
                << " (" << r->file_name << " " << r->line << ":" << r->column << ")"
                << '\n';
        }
    }

    if(want_result_line())
    {
        std::clog
            << "RESULT:"
            << " tests_ok=" << statistics.successful_tests
            << " tests_total=" << statistics.total_tests
            << " assertions_ok=" << statistics.successful_assertions
            << " assertions_total=" << statistics.total_assertions
            << " passed=" << (passed ? "true" : "false")
            << '\n';
    }
}

auto verbose = false;

auto stream = std::ostringstream{};

void reset()
{
    stream = std::ostringstream{};
}

void test_case(const auto& tc)
{
    reset();

    if(tc.test_name.starts_with("scenario") or tc.test_name.starts_with("test_case"))
        stream << color::background::blue
            << tc.test_set_name
            << color::reset << '\n';

    stream << color::text::blue
           << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

void exception(const auto& tc, const auto& ex)
{
    stream << color::background::red
           << ex.what()
           << " " << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

auto demangle(std::string_view name)
{
#if TESTER_HAVE_CXXABI
    int status = 0;
    auto buffer = std::string{name};
    auto demangled = abi::__cxa_demangle(buffer.c_str(), nullptr, nullptr, &status);
    if(demangled != nullptr)
    {
        std::string result{demangled};
        std::free(demangled);
        return result;
    }
#endif
    return std::string{name};
}

auto function_name(const std::source_location sl = std::source_location::current())
{
    using namespace std::literals;
    auto name = std::string_view{sl.function_name()};

    if(auto assertions_pos = name.find("assertions::"); assertions_pos != std::string_view::npos)
        name.remove_prefix(assertions_pos + "assertions::"s.length());

    auto base = name.substr(0, name.find_first_of("("));
    auto display = std::string{base};

    if(auto bracket = name.find('['); bracket != std::string_view::npos)
    {
        auto end = name.find(']', bracket);
        auto parameters = end != std::string_view::npos
                          ? name.substr(bracket + 1, end - bracket - 1)
                          : name.substr(bracket + 1);

        auto trim = [](std::string_view sv)
        {
            auto start = sv.find_first_not_of(" \t");
            if(start == std::string_view::npos) return std::string_view{};
            auto finish = sv.find_last_not_of(" \t");
            return sv.substr(start, finish - start + 1);
        };

        auto clean = [](std::string text)
        {
            auto replace_all = [](std::string& target, std::string_view from, std::string_view to)
            {
                for(auto pos = target.find(from); pos != std::string::npos; pos = target.find(from, pos + to.size()))
                    target.replace(pos, from.size(), to);
            };

            replace_all(text, "std::__1::", "std::");
            replace_all(text, "std::basic_string<char>", "std::string");
            replace_all(text, "std::basic_string<wchar_t>", "std::wstring");
            replace_all(text, " >", ">");

            return text;
        };

        display.push_back(' ');
        display.push_back('[');

        auto remaining = parameters;
        auto first = true;
        while(true)
        {
            auto pos = remaining.find(',');
            auto token = trim(remaining.substr(0, pos));
            if(not token.empty())
            {
                if(not first) display.append(", ");
                auto eq = token.find('=');
                if(eq != std::string_view::npos)
                {
                    auto key = trim(token.substr(0, eq));
                    auto value = trim(token.substr(eq + 1));
                    display.append(std::string{key});
                    display.append("=");
                    display.append(demangle(clean(std::string{value})));
                }
                else
                {
                    display.append(demangle(clean(std::string{token})));
                }
                first = false;
            }
            if(pos == std::string_view::npos) break;
            remaining.remove_prefix(pos + 1);
        }

        display.push_back(']');
    }

    return display;
}

template<class T>
concept chrono_clock = requires {
    typename T::time_point;
    T::now();
};

template <typename V>
void value(const V& val)
{
    using T = std::remove_cvref_t<V>;

    if constexpr (std::is_same_v<T, std::string>)
        stream << demangle(val);
    else if constexpr (std::is_same_v<T, std::string_view>)
        stream << demangle(std::string{val});
    else if constexpr (std::is_same_v<T, const char*> || std::is_same_v<T, char*>)
        stream << demangle(val != nullptr ? std::string{val} : std::string{"nullptr"});
    else if constexpr (std::is_pointer_v<T>)
        stream << (val != nullptr ? val : "nullptr");
    else if constexpr (std::is_enum_v<T>)
        stream << std::to_underlying(val);
    else if constexpr (chrono_clock<T>)
        stream << std::format("{0:%F}T{0:%T}", val);
    else if constexpr (std::is_arithmetic_v<T>)
    {
        if constexpr (std::is_same_v<T, bool>)
            stream << std::boolalpha << val;
        else
            stream << val;
    }

    // ——— NEW: Support for common variant-based JSON/value types ———

    else if constexpr (requires { val.index(); }) // has .index() → probably std::variant or similar
    {
        if (std::holds_alternative<std::monostate>(val) || val.valueless_by_exception())
            stream << "null";
        else
            std::visit([&](const auto& alt) {
                using Alt = std::decay_t<decltype(alt)>;
                if constexpr (std::is_same_v<Alt, bool>)
                    stream << std::boolalpha << alt;
                else if constexpr (std::is_same_v<Alt, std::nullptr_t> || std::is_same_v<Alt, std::monostate>)
                    stream << "null";
                else if constexpr (std::is_same_v<Alt, std::string> || std::is_same_v<Alt, std::string_view>)
                    stream << '"' << alt << '"';
                else if constexpr (std::is_arithmetic_v<Alt>)
                    stream << alt;
                else if constexpr (requires { stream << alt; })
                    stream << alt; // fallback: use existing operator<<
                else
                    stream << "..."; // unknown alternative
            }, val);
    }
    // ——— Final fallback ———
    else if constexpr (requires { stream << val; })
        stream << std::boolalpha << val;
    else
        stream << "..."; // unknown type
}

template<typename A,typename E>
void assertion(const bool ok, const A& actual, const E& expected, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(ok)
        stream << color::text::green;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';

    stream << "  actual:   ";
    value(actual);
    stream << '\n';

    stream << "  expected: ";
    value(expected);
    stream << '\n';

    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

void message(const bool ok, auto message, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(ok)
        stream << color::text::yellow;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';
    stream << "  message:  " << message << '\n';
    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

}

#undef TESTER_HAVE_CXXABI