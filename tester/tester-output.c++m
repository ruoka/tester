// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

module;
#if defined(__GNUG__) && __has_include(<cxxabi.h>)
#   include <cxxabi.h>
#   define TESTER_HAVE_CXXABI 1
#else
#   define TESTER_HAVE_CXXABI 0
#endif
#include <unistd.h>

export module tester:output;
import :data;
import std;

namespace tester::output
{

namespace color
{
    constinit auto reset   = "\033[0m";

    namespace text
    {
        constinit auto black   = "\033[30m"; // black
        constinit auto red     = "\033[31m"; // red
        constinit auto green   = "\033[32m"; // green
        constinit auto yellow  = "\033[33m"; // yellow
        constinit auto blue    = "\033[34m"; // blue
        constinit auto magenta = "\033[35m"; // magenta
        constinit auto cyan    = "\033[36m"; // cyan
        constinit auto white   = "\033[37m"; // white
    }

    namespace background
    {
        constinit auto black   = "\033[40m"; // black
        constinit auto red     = "\033[41m"; // red
        constinit auto green   = "\033[42m"; // green
        constinit auto yellow  = "\033[43m"; // yellow
        constinit auto blue    = "\033[44m"; // blue
        constinit auto magenta = "\033[45m"; // magenta
        constinit auto cyan    = "\033[46m"; // cyan
        constinit auto white   = "\033[47m"; // white
    }
}

using namespace data;

namespace {

constexpr auto jsonl_schema = std::string_view{"tester-jsonl"};
constexpr auto jsonl_version = 1;

enum class output_format { human, jsonl };
enum class jsonl_output_policy { never, failures, always };

auto getenv_sv(const char* name)
{
    if(const char* v = std::getenv(name))
        return std::string_view{v};
    return std::string_view{};
}

auto parse_usize(std::string_view sv)
{
    if(sv.empty()) return std::optional<std::size_t>{};
    std::size_t value = 0;
    for(const char ch : sv)
    {
        if(ch < '0' || ch > '9') return std::optional<std::size_t>{};
        value = value * 10u + static_cast<std::size_t>(ch - '0');
    }
    return std::optional<std::size_t>{value};
}

auto unix_timestamp(std::chrono::system_clock::time_point tp)
{
    return std::chrono::duration_cast<std::chrono::milliseconds>(
        tp.time_since_epoch()).count();
}

auto pid_u32()
{
    return static_cast<std::uint32_t>(::getpid());
}

auto current_format()
{
    static const auto fmt = []{
        auto v = getenv_sv("TESTER_OUTPUT");
        if(v == "jsonl" || v == "JSONL") return output_format::jsonl;
        return output_format::human;
    }();
    return fmt;
}

auto is_jsonl()
{
    return current_format() == output_format::jsonl;
}

auto want_result_line()
{
    // Keep stdout JSONL pure: in JSONL mode, print RESULT to stderr only.
    return is_jsonl() || getenv_sv("TESTER_RESULT") == "1";
}

auto slowest_count()
{
    if(const auto n = parse_usize(getenv_sv("TESTER_SLOWEST")))
        return *n;
    return std::size_t{0};
}

auto jsonl_policy()
{
    static const auto policy = []{
        auto v = getenv_sv("TESTER_JSONL_OUTPUT");
        if(v == "never") return jsonl_output_policy::never;
        if(v == "always") return jsonl_output_policy::always;
        if(v == "failures" || v.empty()) return jsonl_output_policy::failures;

        // Backward compat
        if(getenv_sv("TESTER_JSONL_INCLUDE_OUTPUT") == "1")
            return jsonl_output_policy::always;

        return jsonl_output_policy::failures;
    }();
    return policy;
}

auto jsonl_output_max_bytes()
{
    static const auto max_bytes = []{
        if(const auto n = parse_usize(getenv_sv("TESTER_JSONL_OUTPUT_MAX_BYTES")))
            return *n;
        return std::size_t{16384};
    }();
    return max_bytes;
}

auto json_escape(std::string_view sv)
{
    auto out = std::string{};
    out.reserve(sv.size() + 16);
    for(const unsigned char ch : sv)
    {
        switch(ch)
        {
            case '\\': out += "\\\\"; break;
            case '"':  out += "\\\""; break;
            case '\b': out += "\\b"; break;
            case '\f': out += "\\f"; break;
            case '\n': out += "\\n"; break;
            case '\r': out += "\\r"; break;
            case '\t': out += "\\t"; break;
            default:
                if(ch < 0x20)
                    out += std::format("\\u{:04x}", static_cast<unsigned int>(ch));
                else
                    out.push_back(static_cast<char>(ch));
        }
    }
    return out;
}

auto json_bool(bool b) { return b ? std::string_view{"true"} : std::string_view{"false"}; }

auto as_ms(std::chrono::nanoseconds ns)
{
    return std::chrono::duration_cast<std::chrono::milliseconds>(ns).count();
}

auto strip_ansi(std::string_view sv)
{
    // Strip common ANSI escape sequences so JSONL output stays clean.
    // This is a best-effort filter for sequences like: ESC [ ... letter
    auto out = std::string{};
    out.reserve(sv.size());

    for(std::size_t i = 0; i < sv.size(); )
    {
        const unsigned char ch = static_cast<unsigned char>(sv[i]);
        if(ch == 0x1B && (i + 1) < sv.size() && sv[i + 1] == '[') // ESC [
        {
            i += 2;
            while(i < sv.size())
            {
                const unsigned char c = static_cast<unsigned char>(sv[i]);
                // CSI final byte is in the range 0x40..0x7E.
                if(c >= 0x40 && c <= 0x7E) { ++i; break; }
                ++i;
            }
            continue;
        }

        out.push_back(static_cast<char>(ch));
        ++i;
    }

    return out;
}

auto fnv1a64(std::string_view sv)
{
    std::uint64_t h = 14695981039346656037ull;
    for(const unsigned char c : sv)
    {
        h ^= static_cast<std::uint64_t>(c);
        h *= 1099511628211ull;
    }
    return h;
}

auto hex_u64(std::uint64_t v)
{
    static constexpr char hex[] = "0123456789abcdef";
    char buf[16];
    for(int i = 15; i >= 0; --i)
    {
        buf[i] = hex[v & 0xF];
        v >>= 4;
    }
    return std::string{buf, 16};
}

auto stable_test_id(const test_metadata& m)
{
    auto s = std::string{};
    s.reserve(m.test_name.size() + m.file_name.size() + 32);
    s.append(m.file_name);
    s.push_back(':');
    s.append(std::to_string(m.line));
    s.push_back(':');
    s.append(std::to_string(m.column));
    s.push_back('|');
    s.append(m.test_name);
    return hex_u64(fnv1a64(s));
}

auto prepare_json_output(const std::string& raw)
{
    auto cleaned = strip_ansi(raw);
    const auto original_bytes = cleaned.size();

    const auto max_bytes = jsonl_output_max_bytes();
    auto truncated = false;
    if(max_bytes > 0 && cleaned.size() > max_bytes)
    {
        cleaned.resize(max_bytes);
        cleaned.append("...(truncated)");
        truncated = true;
    }

    return std::tuple{std::move(cleaned), truncated, original_bytes};
}

auto& json_os() { return std::cout; }
auto& human_os() { return std::clog; }
auto& result_os() { return is_jsonl() ? static_cast<std::ostream&>(std::cerr) : static_cast<std::ostream&>(std::clog); }

auto& meta_printed()
{
    static auto printed = false;
    return printed;
}

auto& run_started_unix_ms()
{
    static auto tp = std::chrono::system_clock::time_point{};
    return tp;
}

auto& run_started_monotonic()
{
    static auto tp = std::chrono::steady_clock::time_point{};
    return tp;
}

auto& run_finished_monotonic()
{
    static auto tp = std::chrono::steady_clock::time_point{};
    return tp;
}

auto& run_has_started()
{
    static auto started = false;
    return started;
}

auto& run_mode()
{
    static auto mode = std::string_view{};
    return mode;
}

auto& run_tags()
{
    static auto tags = std::string_view{};
    return tags;
}

void record_run_start(std::string_view mode, std::string_view tags)
{
    run_has_started() = true;
    run_started_unix_ms() = std::chrono::system_clock::now();
    run_started_monotonic() = std::chrono::steady_clock::now();
    run_finished_monotonic() = std::chrono::steady_clock::time_point{};
    run_mode() = mode;
    run_tags() = tags;
}

void record_run_end()
{
    if(run_has_started())
        run_finished_monotonic() = std::chrono::steady_clock::now();
}

void internal_print_meta_once()
{
    if(!is_jsonl() || meta_printed())
        return;

    meta_printed() = true;

    json_os()
        << "{\"type\":\"meta\""
        << ",\"schema\":\"" << json_escape(jsonl_schema) << "\""
        << ",\"version\":" << jsonl_version
        << ",\"pid\":" << pid_u32()
        << ",\"ts_unix_ms\":" << unix_timestamp(std::chrono::system_clock::now())
        << "}\n";
}

void internal_run_start(std::string_view mode, std::string_view tags)
{
    record_run_start(mode, tags);
    if(!is_jsonl()) return;

    internal_print_meta_once();

    json_os()
        << "{\"type\":\"run_start\""
        << ",\"schema\":\"" << json_escape(jsonl_schema) << "\""
        << ",\"version\":" << jsonl_version
        << ",\"pid\":" << pid_u32()
        << ",\"mode\":\"" << json_escape(mode) << "\""
        << ",\"tags\":\"" << json_escape(tags) << "\""
        << ",\"ts_unix_ms\":" << unix_timestamp(run_started_unix_ms())
        << "}\n";
}

void internal_run_end(bool passed)
{
    record_run_end();
    if(!is_jsonl()) return;

    const auto ended_at = std::chrono::system_clock::now();
    const auto ended = unix_timestamp(ended_at);
    const auto dur_ms = (run_started_unix_ms() != std::chrono::system_clock::time_point{})
        ? std::chrono::duration_cast<std::chrono::milliseconds>(ended_at - run_started_unix_ms()).count()
        : 0;

    json_os()
        << "{\"type\":\"run_end\""
        << ",\"schema\":\"" << json_escape(jsonl_schema) << "\""
        << ",\"version\":" << jsonl_version
        << ",\"pid\":" << pid_u32()
        << ",\"mode\":\"" << json_escape(run_mode()) << "\""
        << ",\"tags\":\"" << json_escape(run_tags()) << "\""
        << ",\"passed\":" << json_bool(passed)
        << ",\"duration_ms\":" << dur_ms
        << ",\"ts_unix_ms\":" << ended
        << "}\n";
}

} // namespace

bool jsonl_enabled()
{
    return is_jsonl();
}

void begin_run(std::string_view mode, std::string_view tags)
{
    internal_run_start(mode, tags);
}

void end_run(bool passed)
{
    internal_run_end(passed);
}

void print_test_cases(auto included)
{
    if(is_jsonl())
    {
        internal_print_meta_once();
        for(const auto& tc : test_cases)
        {
            if(!included(tc)) continue;
            json_os()
                << "{\"type\":\"case\""
                << ",\"id\":\"" << stable_test_id(tc) << "\""
                << ",\"set\":\"" << json_escape(tc.test_set_name) << "\""
                << ",\"name\":\"" << json_escape(tc.test_name) << "\""
                << ",\"file\":\"" << json_escape(tc.file_name) << "\""
                << ",\"line\":" << tc.line
                << ",\"column\":" << tc.column
                << ",\"ts_unix_ms\":" << unix_timestamp(std::chrono::system_clock::now())
                << "}\n";
        }
        return;
    }

    human_os() << "Test cases:\n";
    for(auto tc : test_cases)
        if(included(tc))
            human_os() << color::text::yellow
                       << tc.test_name
                       << " (" << tc.file_name << " " << tc.line << ':' << tc.column << ")"
                       << color::reset << std::endl;
}

void print_test_results()
{
    if(is_jsonl())
    {
        const auto policy = jsonl_policy();
        for(const auto& result : test_results)
        {
            const auto include_output = (policy == jsonl_output_policy::always)
                || (policy == jsonl_output_policy::failures && !result.success);

            json_os()
                << "{\"type\":\"test\""
                << ",\"id\":\"" << stable_test_id(result) << "\""
                << ",\"set\":\"" << json_escape(result.test_set_name) << "\""
                << ",\"name\":\"" << json_escape(result.test_name) << "\""
                << ",\"file\":\"" << json_escape(result.file_name) << "\""
                << ",\"line\":" << result.line
                << ",\"column\":" << result.column
                << ",\"success\":" << json_bool(result.success)
                << ",\"duration_ms\":" << as_ms(result.duration);
            json_os()
                << ",\"assertions_ok\":" << result.assertions_ok
                << ",\"assertions_total\":" << result.assertions_total
                << ",\"started_unix_ms\":" << unix_timestamp(result.started_at)
                << ",\"finished_unix_ms\":" << unix_timestamp(result.finished_at);
            if(include_output)
            {
                auto [out, truncated, original_bytes] = prepare_json_output(result.output);
                json_os()
                    << ",\"output\":\"" << json_escape(out) << "\""
                    << ",\"output_truncated\":" << json_bool(truncated)
                    << ",\"output_bytes\":" << original_bytes;
            }
            json_os() << ",\"ts_unix_ms\":" << unix_timestamp(std::chrono::system_clock::now()) << "}\n";
        }
        return;
    }

    human_os() << color::text::yellow
               << "Test results:"
               << color::reset << '\n';
    for(auto result : test_results)
        human_os() << result.output;
}

void print_test_failures()
{
    if(is_jsonl())
        return;

    auto any_failures = false;
    for(const auto& result : test_results)
        if(not result.success) { any_failures = true; break; }

    if(!any_failures)
    {
        human_os() << color::text::green
                   << "No test failures."
                   << color::reset << '\n';
        return;
    }

    human_os() << color::text::red
               << "Test failures:"
               << color::reset << '\n';

    for(const auto& result : test_results)
        if(not result.success)
            human_os() << result.output;
}

void print_test_statistics()
{
    const auto failed_tests = statistics.total_tests - statistics.successful_tests;
    const auto failed_assertions = statistics.total_assertions - statistics.successful_assertions;

    auto pct = [](std::size_t ok, std::size_t total) -> double {
        if(total == 0) return 100.0;
        return 100.0 * static_cast<double>(ok) / static_cast<double>(total);
    };

    const auto passed = (failed_tests == 0 && failed_assertions == 0);

    // Record run end (for duration reporting). In JSONL mode this will also emit run_end later.
    end_run(passed);

    const auto slow_n = slowest_count();
    auto slowest = std::vector<const test_result*>{};
    if(slow_n > 0)
    {
        slowest.reserve(test_results.size());
        for(const auto& r : test_results) slowest.push_back(&r);
        std::ranges::sort(slowest, [](const test_result* a, const test_result* b) {
            return a->duration > b->duration;
        });
        if(slowest.size() > slow_n) slowest.resize(slow_n);
    }

    if(is_jsonl())
    {
        internal_print_meta_once();
        json_os()
            << "{\"type\":\"summary\""
            << ",\"schema\":\"" << json_escape(jsonl_schema) << "\""
            << ",\"version\":" << jsonl_version
            << ",\"pid\":" << pid_u32()
            << ",\"tests_ok\":" << statistics.successful_tests
            << ",\"tests_total\":" << statistics.total_tests
            << ",\"assertions_ok\":" << statistics.successful_assertions
            << ",\"assertions_total\":" << statistics.total_assertions
            << ",\"passed\":" << json_bool(passed);

        if(!slowest.empty())
        {
            json_os() << ",\"slowest\":[";
            for(std::size_t i = 0; i < slowest.size(); ++i)
            {
                const auto& r = *slowest[i];
                if(i) json_os() << ",";
                json_os()
                    << "{\"id\":\"" << stable_test_id(r) << "\""
                    << ",\"name\":\"" << json_escape(r.test_name) << "\""
                    << ",\"file\":\"" << json_escape(r.file_name) << "\""
                    << ",\"line\":" << r.line
                    << ",\"column\":" << r.column
                    << ",\"duration_ms\":" << as_ms(r.duration)
                    << "}";
            }
            json_os() << "]";
        }
        json_os() << ",\"ts_unix_ms\":" << unix_timestamp(std::chrono::system_clock::now()) << "}\n";

        if(want_result_line())
        {
            result_os()
                << "RESULT:"
                << " tests_ok=" << statistics.successful_tests
                << " tests_total=" << statistics.total_tests
                << " assertions_ok=" << statistics.successful_assertions
                << " assertions_total=" << statistics.total_assertions
                << " passed=" << (passed ? "true" : "false")
                << '\n';
        }

        end_run(passed);
        return;
    }

    human_os() << color::text::yellow
               << "Test statistics:" << '\n'
               << "tests:      " << statistics.successful_tests << "/" << statistics.total_tests
               << " passed"
               << " (" << std::fixed << std::setprecision(1) << pct(statistics.successful_tests, statistics.total_tests) << "%)"
               << " | failed: " << failed_tests << '\n'
               << "assertions: " << statistics.successful_assertions << "/" << statistics.total_assertions
               << " passed"
               << " (" << std::fixed << std::setprecision(1) << pct(statistics.successful_assertions, statistics.total_assertions) << "%)"
               << " | failed: " << failed_assertions
               << color::reset << std::endl;

    if(run_has_started() && run_finished_monotonic() != std::chrono::steady_clock::time_point{})
    {
        const auto dur = std::chrono::duration_cast<std::chrono::milliseconds>(
            run_finished_monotonic() - run_started_monotonic());
        human_os() << color::text::yellow
                   << "duration:  " << dur.count() << "ms"
                   << color::reset << '\n';
    }

    if(!run_tags().empty())
    {
        human_os() << color::text::yellow
                   << "filter:    " << run_tags()
                   << color::reset << '\n';
    }

    if(slow_n > 0)
    {
        human_os() << color::text::yellow << "Slowest tests:" << color::reset << '\n';
        for(const auto* r : slowest)
        {
            human_os()
                << "  " << as_ms(r->duration) << "ms  "
                << r->test_name
                << " (" << r->file_name << " " << r->line << ":" << r->column << ")"
                << '\n';
        }
    }

    if(want_result_line())
    {
        result_os()
            << "RESULT:"
            << " tests_ok=" << statistics.successful_tests
            << " tests_total=" << statistics.total_tests
            << " assertions_ok=" << statistics.successful_assertions
            << " assertions_total=" << statistics.total_assertions
            << " passed=" << (passed ? "true" : "false")
            << '\n';
    }
}

auto verbose = false;

auto stream = std::ostringstream{};

void reset()
{
    stream = std::ostringstream{};
}

void test_case(const auto& tc)
{
    reset();

    if(tc.test_name.starts_with("scenario") or tc.test_name.starts_with("test_case"))
        stream << color::background::blue
            << tc.test_set_name
            << color::reset << '\n';

    stream << color::text::blue
           << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

void exception(const auto& tc, const auto& ex)
{
    stream << color::background::red
           << ex.what()
           << " " << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

auto demangle(std::string_view name)
{
#if TESTER_HAVE_CXXABI
    int status = 0;
    auto buffer = std::string{name};
    auto demangled = abi::__cxa_demangle(buffer.c_str(), nullptr, nullptr, &status);
    if(demangled != nullptr)
    {
        std::string result{demangled};
        std::free(demangled);
        return result;
    }
#endif
    return std::string{name};
}

auto function_name(const std::source_location sl = std::source_location::current())
{
    using namespace std::literals;
    auto name = std::string_view{sl.function_name()};

    if(auto assertions_pos = name.find("assertions::"); assertions_pos != std::string_view::npos)
        name.remove_prefix(assertions_pos + "assertions::"s.length());

    auto base = name.substr(0, name.find_first_of("("));
    auto display = std::string{base};

    if(auto bracket = name.find('['); bracket != std::string_view::npos)
    {
        auto end = name.find(']', bracket);
        auto parameters = end != std::string_view::npos
                          ? name.substr(bracket + 1, end - bracket - 1)
                          : name.substr(bracket + 1);

        auto trim = [](std::string_view sv)
        {
            auto start = sv.find_first_not_of(" \t");
            if(start == std::string_view::npos) return std::string_view{};
            auto finish = sv.find_last_not_of(" \t");
            return sv.substr(start, finish - start + 1);
        };

        auto clean = [](std::string text)
        {
            auto replace_all = [](std::string& target, std::string_view from, std::string_view to)
            {
                for(auto pos = target.find(from); pos != std::string::npos; pos = target.find(from, pos + to.size()))
                    target.replace(pos, from.size(), to);
            };

            replace_all(text, "std::__1::", "std::");
            replace_all(text, "std::basic_string<char>", "std::string");
            replace_all(text, "std::basic_string<wchar_t>", "std::wstring");
            replace_all(text, " >", ">");

            return text;
        };

        display.push_back(' ');
        display.push_back('[');

        auto remaining = parameters;
        auto first = true;
        while(true)
        {
            auto pos = remaining.find(',');
            auto token = trim(remaining.substr(0, pos));
            if(not token.empty())
            {
                if(not first) display.append(", ");
                auto eq = token.find('=');
                if(eq != std::string_view::npos)
                {
                    auto key = trim(token.substr(0, eq));
                    auto value = trim(token.substr(eq + 1));
                    display.append(std::string{key});
                    display.append("=");
                    display.append(demangle(clean(std::string{value})));
                }
                else
                {
                    display.append(demangle(clean(std::string{token})));
                }
                first = false;
            }
            if(pos == std::string_view::npos) break;
            remaining.remove_prefix(pos + 1);
        }

        display.push_back(']');
    }

    return display;
}

template<class T>
concept chrono_clock = requires {
    typename T::time_point;
    T::now();
};

template <typename V>
void value(const V& val)
{
    using T = std::remove_cvref_t<V>;

    if constexpr (std::is_same_v<T, std::string>)
        stream << demangle(val);
    else if constexpr (std::is_same_v<T, std::string_view>)
        stream << demangle(std::string{val});
    else if constexpr (std::is_same_v<T, const char*> || std::is_same_v<T, char*>)
        stream << demangle(val != nullptr ? std::string{val} : std::string{"nullptr"});
    else if constexpr (std::is_pointer_v<T>)
        stream << (val != nullptr ? val : "nullptr");
    else if constexpr (std::is_enum_v<T>)
        stream << std::to_underlying(val);
    else if constexpr (chrono_clock<T>)
        stream << std::format("{0:%F}T{0:%T}", val);
    else if constexpr (std::is_arithmetic_v<T>)
    {
        if constexpr (std::is_same_v<T, bool>)
            stream << std::boolalpha << val;
        else
            stream << val;
    }

    // ——— NEW: Support for common variant-based JSON/value types ———

    else if constexpr (requires { val.index(); }) // has .index() → probably std::variant or similar
    {
        if (std::holds_alternative<std::monostate>(val) || val.valueless_by_exception())
            stream << "null";
        else
            std::visit([&](const auto& alt) {
                using Alt = std::decay_t<decltype(alt)>;
                if constexpr (std::is_same_v<Alt, bool>)
                    stream << std::boolalpha << alt;
                else if constexpr (std::is_same_v<Alt, std::nullptr_t> || std::is_same_v<Alt, std::monostate>)
                    stream << "null";
                else if constexpr (std::is_same_v<Alt, std::string> || std::is_same_v<Alt, std::string_view>)
                    stream << '"' << alt << '"';
                else if constexpr (std::is_arithmetic_v<Alt>)
                    stream << alt;
                else if constexpr (requires { stream << alt; })
                    stream << alt; // fallback: use existing operator<<
                else
                    stream << "..."; // unknown alternative
            }, val);
    }
    // ——— Final fallback ———
    else if constexpr (requires { stream << val; })
        stream << std::boolalpha << val;
    else
        stream << "..."; // unknown type
}

template<typename A,typename E>
void assertion(const bool ok, const A& actual, const E& expected, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(ok)
        stream << color::text::green;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';

    stream << "  actual:   ";
    value(actual);
    stream << '\n';

    stream << "  expected: ";
    value(expected);
    stream << '\n';

    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

void message(const bool ok, auto message, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(ok)
        stream << color::text::yellow;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';
    stream << "  message:  " << message << '\n';
    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

}

#undef TESTER_HAVE_CXXABI