// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

export module tester:output;
import :data;
import :jsonl_sink;
import :console_sink;
import :utils;
import std;

namespace tester::output
{

// Per-run configuration (owned by the runner)
inline data::output_config g_config{};

export const data::output_config& cfg()
{
    return g_config;
}

export void set_output_format(std::string_view fmt)
{
    if(fmt == "jsonl" || fmt == "JSONL")
    {
        g_config.format = data::output_format::jsonl;
        console::io_mux().set_jsonl_enabled(true);
    }
    else
    {
        g_config.format = data::output_format::human;
        console::io_mux().set_jsonl_enabled(false);
    }
}

export void set_human_result_line(bool enabled) { g_config.human_result_line = enabled; }
export void set_slowest(std::size_t n) { g_config.slowest = n; }
export void set_jsonl_output(std::string_view policy)
{
    if(policy == "never") g_config.jsonl_output = data::jsonl_output_policy::never;
    else if(policy == "always") g_config.jsonl_output = data::jsonl_output_policy::always;
    else g_config.jsonl_output = data::jsonl_output_policy::failures;
}
export void set_jsonl_output_max_bytes(std::size_t n) { g_config.jsonl_output_max_bytes = n; }

auto& jsonl_sink() { static auto sink = jsonl::sink{console::io_mux()}; return sink; }
auto& console_sink() { return console::sink_instance(); }

export bool jsonl_enabled() { return cfg().format == data::output_format::jsonl; }

export std::string_view captured_output()
{
    if(jsonl_enabled()) return {};
    return console_sink().stream_view();
}

export void begin_run(std::string_view mode, std::string_view tags, std::chrono::system_clock::time_point started_at)
{
    if(!jsonl_enabled()) return;
    jsonl_sink().run_start(mode, tags, started_at);
}

export void end_run(std::string_view mode, std::string_view tags, bool passed, std::chrono::system_clock::time_point started_at, std::chrono::system_clock::time_point ended_at)
{
    if(!jsonl_enabled()) return;
    jsonl_sink().run_end(mode, tags, passed, started_at, ended_at);
}

// Thread-local current test ID (set by runner)
inline thread_local std::string g_current_test_id;
export void set_current_test_id(std::string_view test_id) { g_current_test_id = std::string{test_id}; }
export std::string_view get_current_test_id() { return std::string_view{g_current_test_id}; }

export void print_test_cases(std::function<bool(const data::test_case&)> included)
{
    if(jsonl_enabled()) {
        for(const auto& tc : data::test_cases) { if(!included(tc)) continue; jsonl_sink().test_case(tc); }
        return;
    }
    console_sink().print_test_cases(included);
}

export void print_test_results()
{
    if(jsonl_enabled()) {
        const auto policy = cfg().jsonl_output;
        for(const auto& result : data::test_results) {
            const auto include_output = (policy == data::jsonl_output_policy::always) || (policy == data::jsonl_output_policy::failures && !result.success);
            jsonl_sink().test(result, include_output, cfg().jsonl_output_max_bytes);
        }
        return;
    }
    console_sink().print_test_results();
}

export void print_test_failures()
{
    if(jsonl_enabled()) return;
    console_sink().print_test_failures();
}

export void print_test_statistics(std::optional<bool>& pending_run_end_passed_ref, bool& run_end_emitted_ref, std::string_view run_mode_param)
{
    const auto& stats = data::statistics();
    const auto failed_tests = stats.total_tests - stats.successful_tests;
    const auto failed_assertions = stats.total_assertions - stats.successful_assertions;
    const auto passed = (failed_tests == 0 && failed_assertions == 0);
    const auto slow_n = cfg().slowest;

    auto slowest = std::vector<const data::test_result*>{};
    if(slow_n > 0) {
        slowest.reserve(data::test_results.size());
        for(const auto& r : data::test_results) slowest.push_back(&r);
        std::ranges::sort(slowest, [](const data::test_result* a, const data::test_result* b) { return a->duration > b->duration; });
        if(slowest.size() > slow_n) slowest.resize(slow_n);
    }

    if(jsonl_enabled()) {
        jsonl_sink().summary(stats, passed, std::span<const data::test_result* const>{slowest.data(), slowest.size()});
        if(jsonl_enabled() || cfg().human_result_line) {
            console::result_os() << "RESULT:" << " tests_ok=" << stats.successful_tests << " tests_total=" << stats.total_tests << " assertions_ok=" << stats.successful_assertions << " assertions_total=" << stats.total_assertions << " passed=" << (passed ? "true" : "false") << '\n';
        }
        if(!pending_run_end_passed_ref.has_value()) pending_run_end_passed_ref = passed;
        if(!run_end_emitted_ref && pending_run_end_passed_ref.has_value()) {
            const auto passed_value = *pending_run_end_passed_ref;
            pending_run_end_passed_ref = std::nullopt;
            const auto ended_at = std::chrono::system_clock::now();
            jsonl_sink().run_end(run_mode_param, stats.run_tags, passed_value, stats.run_started_unix_ms, ended_at);
            run_end_emitted_ref = true;
        }
        return;
    }
    console_sink().print_test_statistics(slow_n, stats.run_started, stats.run_finished, stats.run_tags, cfg().human_result_line);
}

export void test_case(const data::test_case& tc) { if(jsonl_enabled()) jsonl_sink().test_case(tc); else console_sink().on_test_case(tc); }
export void exception(const data::test_case& tc, const std::exception& ex) { if(jsonl_enabled()) jsonl_sink().on_exception(tc, ex); else console_sink().on_exception(tc, ex); }

export void emit_jsonl_assertion_event(const data::test_assertion& a)
{
    const auto policy = cfg().jsonl_output;
    if(!a.ok || (policy == data::jsonl_output_policy::always)) jsonl_sink().assertion_event(a);
}

export template<typename A,typename E>
void assertion(const bool ok, const A& actual, const E& expected, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(jsonl_enabled() && !get_current_test_id().empty()) {
        emit_jsonl_assertion_event({ ok, extract_matcher_name(location2), value_to_json_string(actual), value_to_json_string(expected), std::string{get_current_test_id()}, location1.file_name(), location1.line(), location1.column() });
    }
    if(!jsonl_enabled()) console_sink().assertion(ok, actual, expected, location1, location2);
}

export void message(const bool ok, auto msg, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(jsonl_enabled()) {
        if constexpr (std::is_convertible_v<decltype(msg), std::string_view>) jsonl_sink().message(ok, msg, location1, location2);
        else { auto ss = std::ostringstream{}; ss << msg; jsonl_sink().message(ok, ss.str(), location1, location2); }
    } else console_sink().message(ok, msg, location1, location2);
}

}

