// Copyright (c) 2025 Kaius Ruokonen. All rights reserved.
// SPDX-License-Identifier: MIT
// See the LICENSE file in the project root for full license text.

module;
#if defined(__GNUG__) && __has_include(<cxxabi.h>)
#   include <cxxabi.h>
#   define TESTER_HAVE_CXXABI 1
#else
#   define TESTER_HAVE_CXXABI 0
#endif
#include <unistd.h>
#include "../tools/jsonl-format.hpp"
#include "../tools/term.hpp"

export module tester:output;
import :data;
import std;

namespace tester::output
{

namespace color = ::term;

using namespace data;

namespace {

enum class output_format { human, jsonl };
enum class jsonl_output_policy { never, failures, always };

struct output_config
{
    output_format format = output_format::human;
    bool human_result_line = false;
    std::size_t slowest = 0;
    jsonl_output_policy jsonl_output = jsonl_output_policy::failures;
    std::size_t jsonl_output_max_bytes = 16384;
};

// Schema and version are owned by jsonl_context class in jsonl-format.hpp
// Implementation details are encapsulated in jsonl_context

auto& cfg()
{
    static auto config = output_config{};
    return config;
}

// Convert time_point to unix_ms (shared utility)
auto unix_timestamp(std::chrono::system_clock::time_point tp) { return jsonl_util::unix_ms(tp); }


auto current_format()
{
    return cfg().format;
}

auto is_jsonl()
{
    return current_format() == output_format::jsonl;
}

auto want_result_line()
{
    // Keep stdout JSONL pure: in JSONL mode, print RESULT to stderr only.
    return is_jsonl() || cfg().human_result_line;
}

auto slowest_count()
{
    return cfg().slowest;
}

auto jsonl_policy()
{
    return cfg().jsonl_output;
}

auto jsonl_output_max_bytes()
{
    return cfg().jsonl_output_max_bytes;
}

// JSON formatting utilities are now provided by jsonl-format.hpp
using jsonl_util::escape;

auto as_ms(std::chrono::nanoseconds ns)
{
    return std::chrono::duration_cast<std::chrono::milliseconds>(ns).count();
}

auto strip_ansi(std::string_view sv)
{
    // Strip common ANSI escape sequences so JSONL output stays clean.
    // This is a best-effort filter for sequences like: ESC [ ... letter
    auto out = std::string{};
    out.reserve(sv.size());

    for(std::size_t i = 0; i < sv.size(); )
    {
        const unsigned char ch = static_cast<unsigned char>(sv[i]);
        if(ch == 0x1B && (i + 1) < sv.size() && sv[i + 1] == '[') // ESC [
        {
            i += 2;
            while(i < sv.size())
            {
                const unsigned char c = static_cast<unsigned char>(sv[i]);
                // CSI final byte is in the range 0x40..0x7E.
                if(c >= 0x40 && c <= 0x7E) { ++i; break; }
                ++i;
            }
            continue;
        }

        out.push_back(static_cast<char>(ch));
        ++i;
    }

    return out;
}

auto fnv1a64(std::string_view sv)
{
    std::uint64_t h = 14695981039346656037ull;
    for(const unsigned char c : sv)
    {
        h ^= static_cast<std::uint64_t>(c);
        h *= 1099511628211ull;
    }
    return h;
}

auto hex_u64(std::uint64_t v)
{
    static constexpr char hex[] = "0123456789abcdef";
    char buf[16];
    for(int i = 15; i >= 0; --i)
    {
        buf[i] = hex[v & 0xF];
        v >>= 4;
    }
    return std::string{buf, 16};
}

auto prepare_json_output(const std::string& raw)
{
    auto cleaned = strip_ansi(raw);
    const auto original_bytes = cleaned.size();

    const auto max_bytes = jsonl_output_max_bytes();
    auto truncated = false;
    if(max_bytes > 0 && cleaned.size() > max_bytes)
    {
        cleaned.resize(max_bytes);
        cleaned.append("...(truncated)");
        truncated = true;
    }

    return std::tuple{std::move(cleaned), truncated, original_bytes};
}

auto& json_os() { return std::cout; }   // machine output channel
auto& human_os() { return std::clog; } // human/log channel
auto& result_os() { return std::clog; } // always non-JSON, keep off stdout

auto& run_started_unix_ms()
{
    static auto tp = std::chrono::system_clock::time_point{};
    return tp;
}

auto& run_started_monotonic()
{
    static auto tp = std::chrono::steady_clock::time_point{};
    return tp;
}

auto& run_finished_monotonic()
{
    static auto tp = std::chrono::steady_clock::time_point{};
    return tp;
}

auto& run_has_started()
{
    static auto started = false;
    return started;
}

auto& run_mode()
{
    static auto mode = std::string_view{};
    return mode;
}

auto& run_tags()
{
    static auto tags = std::string_view{};
    return tags;
}

auto& current_test_id()
{
    static auto test_id = std::string{};
    return test_id;
}

auto& pending_run_end_passed()
{
    static auto pending = std::optional<bool>{};
    return pending;
}

auto& run_end_emitted()
{
    static auto emitted = false;
    return emitted;
}

// JSONL context using shared utilities from jsonl-format.hpp
// Context owns schema and version as static constants
inline auto& jsonl_ctx()
{
    static auto ctx = jsonl_util::jsonl_context<std::ostream>{json_os()};
    ctx.set_enabled(is_jsonl());
    return ctx;
}

void record_run_start(std::string_view mode, std::string_view tags)
{
    run_has_started() = true;
    run_started_unix_ms() = std::chrono::system_clock::now();
    run_started_monotonic() = std::chrono::steady_clock::now();
    run_finished_monotonic() = std::chrono::steady_clock::time_point{};
    run_mode() = mode;
    run_tags() = tags;
    pending_run_end_passed() = std::nullopt;
    run_end_emitted() = false;
}

void record_run_end()
{
    if(run_has_started())
        run_finished_monotonic() = std::chrono::steady_clock::now();
}

void internal_run_start(std::string_view mode, std::string_view tags)
{
    record_run_start(mode, tags);
    if(!is_jsonl()) return;

    // Single shared JSONL emission style:
    json_os() << jsonl_ctx()("run_start", run_started_unix_ms()) << [&](auto& os){
        os << ",\"mode\":\"" << escape(mode) << "\"";
        os << ",\"tags\":\"" << escape(tags) << "\"";
    };
}

void internal_run_end(bool passed)
{
    record_run_end();
    if(!is_jsonl()) return;

    // In "run" mode, we defer emitting run_end until after the summary so the JSONL stream
    // ends in a predictable order. For other modes (e.g. "list"), emit immediately.
    if(run_mode() == "run")
    {
        pending_run_end_passed() = passed;
        return;
    }

    const auto ended_at = std::chrono::system_clock::now();
    const auto dur_ms = (run_started_unix_ms() != std::chrono::system_clock::time_point{})
        ? jsonl_util::duration_ms(run_started_unix_ms(), ended_at)
        : 0;

    json_os() << jsonl_ctx()("run_end", ended_at) << [&](auto& os){
        os << ",\"mode\":\"" << escape(run_mode()) << "\"";
        os << ",\"tags\":\"" << escape(run_tags()) << "\"";
        os << ",\"passed\":" << (passed ? "true" : "false");
        os << ",\"duration_ms\":" << dur_ms;
    };

    run_end_emitted() = true;
}

// Helper function to emit JSONL assertion events (non-template to avoid TU-local entity warnings)
// Must be in anonymous namespace to access json_escape, jsonl_policy, etc.
void emit_jsonl_assertion_event_impl(
    bool ok,
    std::string_view matcher,
    std::string_view actual_json,
    std::string_view expected_json,
    std::string_view test_id,
    std::string_view file,
    std::uint_least32_t line,
    std::uint_least32_t column)
{
    const auto policy = jsonl_policy();
    const bool should_emit = !ok || (policy == jsonl_output_policy::always);
    
    if(should_emit)
    {
        json_os() << jsonl_ctx()(ok ? "assertion_passed" : "assertion_failed") << [&](auto& os){
            os << ",\"test_id\":\"" << escape(test_id) << "\"";
            os << ",\"matcher\":\"" << escape(matcher) << "\"";
            os << ",\"actual\":" << actual_json;
            os << ",\"expected\":" << expected_json;
            os << ",\"file\":\"" << escape(file) << "\"";
            os << ",\"line\":" << line;
            os << ",\"column\":" << column;
        };
    }
}

} // namespace

export auto stable_test_id(const test_metadata& m)
{
    auto s = std::string{};
    s.reserve(m.test_name.size() + m.file_name.size() + 32);
    s.append(m.file_name);
    s.push_back(':');
    s.append(std::to_string(m.line));
    s.push_back(':');
    s.append(std::to_string(m.column));
    s.push_back('|');
    s.append(m.test_name);
    return hex_u64(fnv1a64(s));
}

bool jsonl_enabled()
{
    return is_jsonl();
}

export void set_output_format(std::string_view fmt)
{
    if(fmt == "jsonl" || fmt == "JSONL") cfg().format = output_format::jsonl;
    else cfg().format = output_format::human;
}

export void set_human_result_line(bool enabled)
{
    cfg().human_result_line = enabled;
}

export void set_slowest(std::size_t n)
{
    cfg().slowest = n;
}

export void set_jsonl_output(std::string_view policy)
{
    if(policy == "never") cfg().jsonl_output = jsonl_output_policy::never;
    else if(policy == "always") cfg().jsonl_output = jsonl_output_policy::always;
    else cfg().jsonl_output = jsonl_output_policy::failures;
}

export void set_jsonl_output_max_bytes(std::size_t n)
{
    cfg().jsonl_output_max_bytes = n;
}

export void set_current_test_id(std::string_view id)
{
    current_test_id().assign(id.begin(), id.end());
}

export void clear_current_test_id()
{
    current_test_id().clear();
}

export std::string_view get_current_test_id()
{
    return current_test_id();
}

void begin_run(std::string_view mode, std::string_view tags)
{
    internal_run_start(mode, tags);
}

void end_run(bool passed)
{
    internal_run_end(passed);
}

void print_test_cases(auto included)
{
    if(is_jsonl())
    {
        for(const auto& tc : test_cases)
        {
            if(!included(tc)) continue;
            json_os() << jsonl_ctx()("case") << [&](auto& os){
                os << ",\"id\":\"" << stable_test_id(tc) << "\"";
                os << ",\"set\":\"" << escape(tc.test_set_name) << "\"";
                os << ",\"name\":\"" << escape(tc.test_name) << "\"";
                os << ",\"file\":\"" << escape(tc.file_name) << "\"";
                os << ",\"line\":" << tc.line;
                os << ",\"column\":" << tc.column;
            };
        }
        return;
    }

    human_os() << "Test cases:\n";
    for(auto tc : test_cases)
        if(included(tc))
            human_os() << color::text::yellow
                       << tc.test_name
                       << " (" << tc.file_name << " " << tc.line << ':' << tc.column << ")"
                       << color::reset << std::endl;
}

void print_test_results()
{
    if(is_jsonl())
    {
        const auto policy = jsonl_policy();
        for(const auto& result : test_results)
        {
            const auto include_output = (policy == jsonl_output_policy::always)
                || (policy == jsonl_output_policy::failures && !result.success);

            json_os() << jsonl_ctx()("test") << [&](auto& os){
                os << ",\"id\":\"" << stable_test_id(result) << "\"";
                os << ",\"set\":\"" << escape(result.test_set_name) << "\"";
                os << ",\"name\":\"" << escape(result.test_name) << "\"";
                os << ",\"file\":\"" << escape(result.file_name) << "\"";
                os << ",\"line\":" << result.line;
                os << ",\"column\":" << result.column;
                os << ",\"success\":" << (result.success ? "true" : "false");
                os << ",\"duration_ms\":" << as_ms(result.duration);
                os << ",\"assertions_ok\":" << result.assertions_ok;
                os << ",\"assertions_total\":" << result.assertions_total;
                os << ",\"started_unix_ms\":" << unix_timestamp(result.started_at);
                os << ",\"finished_unix_ms\":" << unix_timestamp(result.finished_at);
                if(include_output)
                {
                    auto [out, truncated, original_bytes] = prepare_json_output(result.output);
                    os << ",\"output\":\"" << escape(out) << "\"";
                    os << ",\"output_truncated\":" << (truncated ? "true" : "false");
                    os << ",\"output_bytes\":" << original_bytes;
                }
            };
        }
        return;
    }

    human_os() << color::text::yellow
               << "Test results:"
               << color::reset << '\n';
    for(auto result : test_results)
        human_os() << result.output;
}

void print_test_failures()
{
    if(is_jsonl())
        return;

    auto any_failures = false;
    for(const auto& result : test_results)
        if(not result.success) { any_failures = true; break; }

    if(!any_failures)
    {
        human_os() << color::text::green
                   << "No test failures."
                   << color::reset << '\n';
        return;
    }

    human_os() << color::text::red
               << "Test failures:"
               << color::reset << '\n';

    for(const auto& result : test_results)
        if(not result.success)
            human_os() << result.output;
}

void print_test_statistics()
{
    const auto failed_tests = statistics.total_tests - statistics.successful_tests;
    const auto failed_assertions = statistics.total_assertions - statistics.successful_assertions;

    auto pct = [](std::size_t ok, std::size_t total) -> double {
        if(total == 0) return 100.0;
        return 100.0 * static_cast<double>(ok) / static_cast<double>(total);
    };

    const auto passed = (failed_tests == 0 && failed_assertions == 0);

    const auto slow_n = slowest_count();
    auto slowest = std::vector<const test_result*>{};
    if(slow_n > 0)
    {
        slowest.reserve(test_results.size());
        for(const auto& r : test_results) slowest.push_back(&r);
        std::ranges::sort(slowest, [](const test_result* a, const test_result* b) {
            return a->duration > b->duration;
        });
        if(slowest.size() > slow_n) slowest.resize(slow_n);
    }

    if(is_jsonl())
    {
        json_os() << jsonl_ctx()("summary") << [&](auto& os){
            os << ",\"tests_ok\":" << statistics.successful_tests;
            os << ",\"tests_total\":" << statistics.total_tests;
            os << ",\"assertions_ok\":" << statistics.successful_assertions;
            os << ",\"assertions_total\":" << statistics.total_assertions;
            os << ",\"passed\":" << (passed ? "true" : "false");
            if(!slowest.empty())
            {
                os << ",\"slowest\":[";
                for(std::size_t i = 0; i < slowest.size(); ++i)
                {
                    const auto& r = *slowest[i];
                    if(i) os << ",";
                    os << "{\"id\":\"" << stable_test_id(r) << "\"";
                    os << ",\"name\":\"" << escape(r.test_name) << "\"";
                    os << ",\"file\":\"" << escape(r.file_name) << "\"";
                    os << ",\"line\":" << r.line;
                    os << ",\"column\":" << r.column;
                    os << ",\"duration_ms\":" << as_ms(r.duration);
                    os << "}";
                }
                os << "]";
            }
        };

        if(want_result_line())
        {
            result_os()
                << "RESULT:"
                << " tests_ok=" << statistics.successful_tests
                << " tests_total=" << statistics.total_tests
                << " assertions_ok=" << statistics.successful_assertions
                << " assertions_total=" << statistics.total_assertions
                << " passed=" << (passed ? "true" : "false")
                << '\n';
        }

        // Emit deferred run_end exactly once, after summary.
        if(!pending_run_end_passed().has_value())
            pending_run_end_passed() = passed;

        if(!run_end_emitted() && pending_run_end_passed().has_value())
        {
            const auto passed_value = *pending_run_end_passed();
            pending_run_end_passed() = std::nullopt;

            const auto ended_at = std::chrono::system_clock::now();
            const auto dur_ms = (run_started_unix_ms() != std::chrono::system_clock::time_point{})
                ? jsonl_util::duration_ms(run_started_unix_ms(), ended_at)
                : 0;

            json_os() << jsonl_ctx()("run_end", ended_at) << [&](auto& os){
                os << ",\"mode\":\"" << escape(run_mode()) << "\"";
                os << ",\"tags\":\"" << escape(run_tags()) << "\"";
                os << ",\"passed\":" << (passed_value ? "true" : "false");
                os << ",\"duration_ms\":" << dur_ms;
            };

            run_end_emitted() = true;
        }
        return;
    }

    human_os() << color::text::yellow
               << "Test statistics:" << '\n'
               << "tests:      " << statistics.successful_tests << "/" << statistics.total_tests
               << " passed"
               << " (" << std::fixed << std::setprecision(1) << pct(statistics.successful_tests, statistics.total_tests) << "%)"
               << " | failed: " << failed_tests << '\n'
               << "assertions: " << statistics.successful_assertions << "/" << statistics.total_assertions
               << " passed"
               << " (" << std::fixed << std::setprecision(1) << pct(statistics.successful_assertions, statistics.total_assertions) << "%)"
               << " | failed: " << failed_assertions
               << color::reset << std::endl;

    // Record run end (for duration reporting in human output).
    record_run_end();

    if(run_has_started() && run_finished_monotonic() != std::chrono::steady_clock::time_point{})
    {
        const auto dur = std::chrono::duration_cast<std::chrono::milliseconds>(
            run_finished_monotonic() - run_started_monotonic());
        human_os() << color::text::yellow
                   << "duration:  " << dur.count() << "ms"
                   << color::reset << '\n';
    }

    if(!run_tags().empty())
    {
        human_os() << color::text::yellow
                   << "filter:    " << run_tags()
                   << color::reset << '\n';
    }

    if(slow_n > 0)
    {
        human_os() << color::text::yellow << "Slowest tests:" << color::reset << '\n';
        for(const auto* r : slowest)
        {
            human_os()
                << "  " << as_ms(r->duration) << "ms  "
                << r->test_name
                << " (" << r->file_name << " " << r->line << ":" << r->column << ")"
                << '\n';
        }
    }

    if(want_result_line())
    {
        result_os()
            << "RESULT:"
            << " tests_ok=" << statistics.successful_tests
            << " tests_total=" << statistics.total_tests
            << " assertions_ok=" << statistics.successful_assertions
            << " assertions_total=" << statistics.total_assertions
            << " passed=" << (passed ? "true" : "false")
            << '\n';
    }
}

auto verbose = false;

auto stream = std::ostringstream{};

void reset()
{
    stream = std::ostringstream{};
}

void test_case(const auto& tc)
{
    reset();

    if(tc.test_name.starts_with("scenario") or tc.test_name.starts_with("test_case"))
        stream << color::background::blue
            << tc.test_set_name
            << color::reset << '\n';

    stream << color::text::blue
           << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

void exception(const auto& tc, const auto& ex)
{
    stream << color::background::red
           << ex.what()
           << " " << tc.test_name << " "
           << "(" << tc.file_name << " " <<  tc.line << ":" <<  tc.column << ")"
           << color::reset << '\n';
}

auto demangle(std::string_view name)
{
#if TESTER_HAVE_CXXABI
    int status = 0;
    auto buffer = std::string{name};
    auto demangled = abi::__cxa_demangle(buffer.c_str(), nullptr, nullptr, &status);
    if(demangled != nullptr)
    {
        std::string result{demangled};
        std::free(demangled);
        return result;
    }
#endif
    return std::string{name};
}

auto function_name(const std::source_location sl = std::source_location::current())
{
    using namespace std::literals;
    auto name = std::string_view{sl.function_name()};

    if(auto assertions_pos = name.find("assertions::"); assertions_pos != std::string_view::npos)
        name.remove_prefix(assertions_pos + "assertions::"s.length());

    auto base = name.substr(0, name.find_first_of("("));
    auto display = std::string{base};

    if(auto bracket = name.find('['); bracket != std::string_view::npos)
    {
        auto end = name.find(']', bracket);
        auto parameters = end != std::string_view::npos
                          ? name.substr(bracket + 1, end - bracket - 1)
                          : name.substr(bracket + 1);

        auto trim = [](std::string_view sv)
        {
            auto start = sv.find_first_not_of(" \t");
            if(start == std::string_view::npos) return std::string_view{};
            auto finish = sv.find_last_not_of(" \t");
            return sv.substr(start, finish - start + 1);
        };

        auto clean = [](std::string text)
        {
            auto replace_all = [](std::string& target, std::string_view from, std::string_view to)
            {
                for(auto pos = target.find(from); pos != std::string::npos; pos = target.find(from, pos + to.size()))
                    target.replace(pos, from.size(), to);
            };

            replace_all(text, "std::__1::", "std::");
            replace_all(text, "std::basic_string<char>", "std::string");
            replace_all(text, "std::basic_string<wchar_t>", "std::wstring");
            replace_all(text, " >", ">");

            return text;
        };

        display.push_back(' ');
        display.push_back('[');

        auto remaining = parameters;
        auto first = true;
        while(true)
        {
            auto pos = remaining.find(',');
            auto token = trim(remaining.substr(0, pos));
            if(not token.empty())
            {
                if(not first) display.append(", ");
                auto eq = token.find('=');
                if(eq != std::string_view::npos)
                {
                    auto key = trim(token.substr(0, eq));
                    auto value = trim(token.substr(eq + 1));
                    display.append(std::string{key});
                    display.append("=");
                    display.append(demangle(clean(std::string{value})));
                }
                else
                {
                    display.append(demangle(clean(std::string{token})));
                }
                first = false;
            }
            if(pos == std::string_view::npos) break;
            remaining.remove_prefix(pos + 1);
        }

        display.push_back(']');
    }

    return display;
}

// Extract matcher name from function name (e.g., "require_eq", "check_contains")
auto extract_matcher_name(const std::source_location sl)
{
    using namespace std::literals;
    auto name = std::string_view{sl.function_name()};
    
    // Find "assertions::" prefix and extract the matcher name
    if(auto assertions_pos = name.find("assertions::"); assertions_pos != std::string_view::npos)
        name.remove_prefix(assertions_pos + "assertions::"s.length());
    
    // Extract base function name (before '(' or '<')
    auto end = name.find_first_of("(<");
    auto base = name.substr(0, end != std::string_view::npos ? end : name.size());
    
    return std::string{base};
}

// Format value as JSON string (for structured assertion events)
template <typename V>
std::string value_to_json_string(const V& val)
{
    auto ss = std::ostringstream{};
    using T = std::remove_cvref_t<V>;
    
    if constexpr (std::is_same_v<T, std::string>)
        ss << '"' << escape(val) << '"';
    else if constexpr (std::is_same_v<T, std::string_view>)
        ss << '"' << escape(val) << '"';
    else if constexpr (std::is_same_v<T, const char*> || std::is_same_v<T, char*>)
        ss << '"' << escape(val != nullptr ? std::string_view{val} : std::string_view{"nullptr"}) << '"';
    else if constexpr (std::is_pointer_v<T>)
    {
        if(val != nullptr)
        {
            auto temp = std::ostringstream{};
            temp << val;
            ss << '"' << escape(temp.str()) << '"';
        }
        else
            ss << "\"nullptr\"";
    }
    else if constexpr (std::is_enum_v<T>)
        ss << std::to_underlying(val);
    else if constexpr (std::is_arithmetic_v<T>)
    {
        if constexpr (std::is_same_v<T, bool>)
            ss << (val ? "true" : "false");
        else
            ss << val;
    }
    else
    {
        // For complex types, format using ostringstream and escape as JSON string
        auto temp = std::ostringstream{};
        temp << val;
        ss << '"' << escape(temp.str()) << '"';
    }
    
    return ss.str();
}

template<class T>
concept chrono_clock = requires {
    typename T::time_point;
    T::now();
};

template <typename V>
void value(const V& val)
{
    using T = std::remove_cvref_t<V>;

    if constexpr (std::is_same_v<T, std::string>)
        stream << demangle(val);
    else if constexpr (std::is_same_v<T, std::string_view>)
        stream << demangle(std::string{val});
    else if constexpr (std::is_same_v<T, const char*> || std::is_same_v<T, char*>)
        stream << demangle(val != nullptr ? std::string{val} : std::string{"nullptr"});
    else if constexpr (std::is_pointer_v<T>)
        stream << (val != nullptr ? val : "nullptr");
    else if constexpr (std::is_enum_v<T>)
        stream << std::to_underlying(val);
    else if constexpr (chrono_clock<T>)
        stream << std::format("{0:%F}T{0:%T}", val);
    else if constexpr (std::is_arithmetic_v<T>)
    {
        if constexpr (std::is_same_v<T, bool>)
            stream << std::boolalpha << val;
        else
            stream << val;
    }

    // ——— NEW: Support for common variant-based JSON/value types ———

    else if constexpr (requires { val.index(); }) // has .index() → probably std::variant or similar
    {
        if (std::holds_alternative<std::monostate>(val) || val.valueless_by_exception())
            stream << "null";
        else
            std::visit([&](const auto& alt) {
                using Alt = std::decay_t<decltype(alt)>;
                if constexpr (std::is_same_v<Alt, bool>)
                    stream << std::boolalpha << alt;
                else if constexpr (std::is_same_v<Alt, std::nullptr_t> || std::is_same_v<Alt, std::monostate>)
                    stream << "null";
                else if constexpr (std::is_same_v<Alt, std::string> || std::is_same_v<Alt, std::string_view>)
                    stream << '"' << alt << '"';
                else if constexpr (std::is_arithmetic_v<Alt>)
                    stream << alt;
                else if constexpr (requires { stream << alt; })
                    stream << alt; // fallback: use existing operator<<
                else
                    stream << "..."; // unknown alternative
            }, val);
    }
    // ——— Final fallback ———
    else if constexpr (requires { stream << val; })
        stream << std::boolalpha << val;
    else
        stream << "..."; // unknown type
}

// Wrapper function in module namespace that calls the anonymous namespace implementation
void emit_jsonl_assertion_event_wrapper(
    bool ok,
    std::string_view matcher,
    std::string_view actual_json,
    std::string_view expected_json,
    std::string_view test_id,
    std::string_view file,
    std::uint_least32_t line,
    std::uint_least32_t column)
{
    // Forward to the anonymous namespace implementation
    emit_jsonl_assertion_event_impl(ok, matcher, actual_json, expected_json, test_id, file, line, column);
}

template<typename A,typename E>
void assertion(const bool ok, const A& actual, const E& expected, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    // Emit structured JSONL assertion event if in JSONL mode
    // Use exported wrapper functions to avoid TU-local entity warnings
    if(jsonl_enabled() && !get_current_test_id().empty())
    {
        const auto matcher = extract_matcher_name(location2);
        const auto actual_str = value_to_json_string(actual);
        const auto expected_str = value_to_json_string(expected);
        const auto test_id = get_current_test_id();
        
        emit_jsonl_assertion_event_wrapper(
            ok,
            matcher,
            actual_str,
            expected_str,
            test_id,
            location1.file_name(),
            location1.line(),
            location1.column());
    }
    
    // Always generate human-readable output
    if(ok)
        stream << color::text::green;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';

    stream << "  actual:   ";
    value(actual);
    stream << '\n';

    stream << "  expected: ";
    value(expected);
    stream << '\n';

    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

void message(const bool ok, auto message, const std::source_location location1, const std::source_location location2 = std::source_location::current())
{
    if(ok)
        stream << color::text::yellow;
    else
        stream << color::text::red;

    stream << function_name(location2) << '\n';
    stream << "  message:  " << message << '\n';
    stream << "  location: "
           << location1.file_name() << " "
           << location1.line() << ":" << location1.column()
           << color::reset << '\n';

    if(verbose) std::clog << stream.view();
}

}

#undef TESTER_HAVE_CXXABI